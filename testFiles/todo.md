// TODO 1: 数据预处理与清洗
        // - 输入数据有效性验证：
        //   * 空值检查：wgs84Points列表为空、null
        //   * 点数检查：少于最小点数阈值（如10个点）
        //   * 幅宽检查：totalWidthM必须>0
        // - 轨迹点过滤与清洗：
        //   * 经纬度范围验证：经度[-180,180]，纬度[-90,90]
        //   * **无效坐标过滤**（基于实际数据特征）：
        //     - 零值检查：lon=0且lat=0（GPS未定位时的默认值）
        //     - 范围异常：经纬度超出基本合理范围（纬度-90~90度，经度-180~180度）
        //     - 异常跳点过滤（基于轨迹自身特征）：
        //       * 推算速度>20km/h（超出自动驾驶车辆最高速度18km/h，视为异常）
        //       * 轨迹不连续：单点跳变>200米且前后轨迹方向不一致（排除地块间转移）
        //       * 孤立噪点：单点周围50米内邻居点<3个（需结合前后轨迹判断，避免误删新地块起始点）
        //     - 注意：double类型不会出现NaN/Infinity，无需检查
        //   * 重复点过滤：连续相同坐标的点只保留第一个
        //   * **作业中断识别**（替代简单跳点过滤）：
        //     - 作业中断智能识别（仅基于轨迹特征）：
        //       * 地块间转移：间距>200米（轨迹明显跳跃，可能切换地块）
        //       * 轨迹连续：间距<20米（位置连续，视为正常作业）
        //       * 异常跳点：单点间距>500米（明显GPS漂移，需单独过滤）
        //       * 时间间隔：仅用于统计分析，不作为分割依据
        //       * 轨迹分段：基于距离连续性，不依赖设备状态
        //     - 标记中断类型：'location_change'（位置变化）、'trajectory_jump'（轨迹跳跃）
        //     - 中断点保留：不删除中断点，而是标记为潜在的作业段分界点
        //     - 连续中断处理：多个连续大间隔点形成'行驶段'，与'作业段'区分
        //   * 异常跳点过滤（仅针对明显错误）：
        //     - 超远距离跳变：单点跳跃>500米且周围点正常，可能是GPS错误
        //     - 速度异常：瞬时速度>20km/h且孤立出现（超出自动驾驶车辆最高速度18km/h）
        // - 时间序列处理：
        //   * 按时间戳升序排序
        //   * **作业中断时间分析**：
        //     - 短时间间隔：<5分钟（正常作业连续）
        //     - 中等时间间隔：5-30分钟（地头转弯、短暂休息）
        //     - 长时间间隔：>30分钟（地块间转移、日间休息）
        //     - 超长时间间隔：>2小时（日间停工、设备故障）
        // - 坐标系处理：
        //   * 动态UTM投影：根据轨迹中心经度自动计算UTM带号，临时投影到UTM带进行精确计算，结果转回WGS84存储展示
        //   * 距离计算：使用Haversine公式计算球面距离（精度足够）
        //   * 全球适用：支持国内外所有区域，无投影变形问题
        //   * 不采用高斯投影：避免6度分带限制，支持全球农业区域（美国、巴西、澳洲等）
        // - WGS84与UTM投影转换详细步骤：
        //   1. 确定轨迹中心点：计算所有轨迹点的平均经纬度
        //   2. 根据中心点经度确定UTM投影带：zone = Math.floor((lon + 180) / 6) + 1
        //   3. 判断北半球/南半球：根据中心点纬度
        //   4. 创建坐标转换对象：
        //      - 使用Proj4j库创建从EPSG:4326到EPSG:32XXX的转换
        //      - 对于北半球，EPSG代码为326XX；南半球为327XX
        //   5. 批量转换所有轨迹点：
        //      - 将WGS84经纬度坐标转换为UTM投影坐标
        //      - 存储转换后的坐标用于距离和面积计算
        //   6. 保留原始WGS84坐标：用于最终结果返回
        //   7. 转换验证：
        //      - 计算转换前后的距离误差，确保在可接受范围内
        //      - 验证转换后的坐标是否合理（非NaN、非无穷大）
        //   8. 动态异常处理：
        //      - 轨迹跨UTM带处理：对于跨越多个UTM带的长轨迹，采用分段投影策略
        //      - 转换失败点处理：保留原始WGS84坐标，并记录转换失败原因
        //      - 精度控制：设置转换精度阈值，低于阈值的坐标差异视为有效

        // TODO 2: 特征提取引擎
        // - 空间密度特征计算：
        //   * 使用STRtree空间索引加速邻居查询
        //   * 搜索半径：totalWidthM * 1.5（幅宽的1.5倍）
        //   * 密度标准化：邻居数/最大可能邻居数
        // - 方向熵特征计算：
        //   * 滑动窗口大小：5-7个轨迹点
        //   * 方向角计算：atan2(Δy, Δx)转换为0-360度
        //   * 熵值计算：-Σ(p_i * log(p_i))，p_i为方向分布概率
        //   * 归一化：熵值/理论最大熵值
        // - 轨迹自交密度计算：
        //   * 局部轨迹段：当前点前后各N个点（N=3-5）
        //   * 自交检测：线段相交检测算法
        //   * 自交密度：单位长度内的自交次数
        //   * 加权处理：距离当前点越近的自交权重越大
        // - 辅助特征计算（可选）：
        //   * 速度特征：相邻点平均速度、速度变化率
        //   * 时间特征：作业时间段识别（排除夜间、休息时间）
        //   * 几何特征：轨迹曲率、转弯半径

        // TODO 3: 轨迹点分类
        // - 特征权重设置：
        //   * 空间密度权重：0.4（作业区域密度高，道路密度低）
        //   * 方向熵权重：0.3（作业方向变化复杂，道路方向稳定）
        //   * 自交密度权重：0.3（作业轨迹频繁自交，道路轨迹无自交）
        // - 分类阈值确定：
        //   * 作业点判定阈值：综合得分 >= 0.6
        //   * 道路点判定阈值：综合得分 < 0.4
        //   * 模糊区域：0.4 <= 综合得分 < 0.6（需进一步处理）
        // - 分类算法实现：
        //   * 加权求和：score = w1*density + w2*entropy + w3*selfIntersection
        //   * 动态阈值调整：基于轨迹整体特征分布自适应调整
        // - 后处理优化：
        //   * 滑动窗口平滑：窗口大小5-7个点，多数投票决策
        //   * 孤立点消除：单个异类点被同类邻居同化
        //   * 边界处理：轨迹起始/结束点的特殊处理
        // - 具体实现步骤：
        //   1. 初始化分类数组：boolean[] isWorkingPoint = new boolean[filteredPoints.size()];
        //   2. 计算每个点的特征向量：
        //      - 使用STRtree加速邻居点查询
        //      - 对每个点，计算其在DENSITY_RADIUS范围内的邻居点数
        //      - 计算方向变化标准差（滑动窗口大小为5-7个点）
        //      - 计算轨迹自交密度（局部线段自交检测）
        //   3. 特征归一化：将所有特征值映射到[0,1]区间
        //   4. 计算综合得分：应用权重计算每个点的分类得分
        //   5. 初步分类：根据阈值标记作业点和道路点
        //   6. 模糊区域处理：
        //      - 检查模糊点的前后点分类
        //      - 使用马尔可夫链模型推断模糊点最可能的类别
        //   7. 分类结果平滑：
        //      - 应用5点滑动窗口进行多数投票
        //      - 处理孤立点（周围4个点同类则被同化）
        //   8. 分类结果验证：
        //      - 检查作业段的最小长度和密度要求
        //      - 过滤掉明显不合理的作业段
        //   9. 保存分类结果：将分类信息存储用于后续处理

        // TODO 4: 轨迹分段与合并
        // - 作业段识别：
        //   * 连续作业点序列：最少连续点数阈值（如30个点）
        //     - 基于轨迹连续性的段分割（纯距离判断）：
        //       * 地块间转移：间距>200米 → 新作业段（轨迹明显跳跃，强制分段）
        //       * 轨迹连续：间距<20米 → 连续作业段（位置连续，正常作业）
        //       * 地头转弯：间距<50米 → 连续作业段（地块内正常转向）
        //       * 异常跳点：间距>200米 → 疑似地块转移或GPS漂移，需结合轨迹验证
        //     - 时间仅作统计：用于生成作业报告，不作为分割依据
        //     - 轨迹分段：基于距离连续性，不依赖设备状态
        //   * 段间关系判断：
        //     - 空间关系：段间距、方向一致性
        //     - 时间关系：段间时间间隔、作业时段连续性
        //     - 逻辑关系：基于地块形状的作业合理性
        // - 段合并策略（考虑中断类型）：
        //   * **同地块段合并（距离为主，忽略时间）**：
        //     - 空间邻近：段间距<totalWidthM * 2.0（考虑幅宽和GPS精度，约20-50米）
        //     - 形状匹配：段方向一致或互补（平行作业模式）
        //     - 轨迹连续：检查段间是否有连续轨迹（忽略时间间隔）
        //     - 地块内暂停合并：对于间距<20米的暂停段，检查前后轨迹是否连续（忽略时间长短）
        //   * **跨地块段保留**：
        //     - 大间距段：间距>200米 → 保留为独立地块（不同地块间，含地块间转移）
        //     - 明显转向：方向变化>90度 → 可能是不同地块
        //     - 空间分离：段间有明显物理分隔（如道路、沟渠）
        //   * 合并验证：
        //     - 合并后形状合理性：长宽比、紧凑度检查
        //     - 合并后轨迹连续性：中间无大的空洞或跳跃
        // - 噪声过滤：
        //   * 最短作业段：最少点数（如30个点）或最短距离（如50米）
        //   * 面积过滤：作业区域面积<最小面积阈值（如150平方米）
        //   * 密度过滤：段内平均密度<密度阈值（如最大密度的30%）
        // - 边界扩展：
        //   * 向前后各扩展N个点（如2-3个点）提高段完整性
        //   * 扩展点标记：区分原始作业点与扩展点
        // - 段特征提取：
        //   * 每段的起止时间、中心点、方向、长度
        //   * 段的作业面积、作业效率、平均速度

        // TODO 5: 作业区域生成与优化
        // - 缓冲区生成：
        //   * 线缓冲区：对轨迹线段生成线缓冲区（宽度=totalWidthM），避免单点圆形缓冲区性能问题
        //   * 智能分段：轨迹点过多时自动分段处理，支持并行计算
        //   * 分批处理：86400个点采用分批并发策略，避免内存溢出和性能瓶颈
        //   * 线段缓冲区：对线轨迹段生成线缓冲区（宽度=totalWidthM）
        //   * 缓冲区合并：使用Union操作合并重叠缓冲区
        //   * 线性缓冲区相比圆形缓冲区的优势：
        //     - 内存占用更低：线性缓冲区只需要存储线段两侧的多边形，而圆形缓冲区需要为每个点生成圆形区域
        //     - 执行时间更短：线性缓冲区计算复杂度为O(n)，圆形缓冲区为O(n²)
        //     - 更符合作业机具工作模式：农业机械作业轨迹通常是连续的带状区域
        //     - 边界更平滑：避免了圆形缓冲区在轨迹方向变化处产生的锯齿状边界
        //   * 线性缓冲区具体实现：
        //     - 使用JTS的LineString.buffer(distance, quadrantSegments)
        //     - 幅宽设置：distance = totalWidthM / 2
        //   * 线段端点处理：采用FLAT端点类型（CAP_FLAT）
          //   * 线段连接方式：采用MITER连接（JOIN_MITRE）
          //   * 曲线细分参数：quadrantSegments = 1（对于直线轨迹足够，提高性能）
          // - 性能优化：
          //   * 对长轨迹段进行分段处理
          //   * 使用空间索引加速缓冲区合并
          // - 缓冲区生成具体步骤：
          //   1. 将分类后的作业轨迹点转换为LineString
          //   2. 计算线性缓冲区：bufferWidth = totalWidthM / 2
          //   3. 使用较低的quadrantSegments值（如1-2）提高性能
          //   4. 合并相邻缓冲区：使用union()操作
          //   5. 简化合并后的多边形：提高后续计算效率
        // - 几何优化：
        //   * 平滑处理：使用Douglas-Peucker算法简化边界（容差0.5-1.0米）
        //   * 孔洞填充：
        //     - 推荐使用形态学操作：先膨胀0.5米再收缩0.5米，可有效填充小缝隙
        //     - 辅助方法：填充缓冲区内部的小孔洞（面积<阈值）
        //   * 边界清理：移除锯齿状边界，保持农业地块的自然形状
        // - 拓扑检查：
        //   * 自相交检测：确保生成的几何图形无自相交
        //   * 有效性验证：几何图形必须有效（isValid()检查）
        //   * 简单性检查：复杂度过高的几何进行简化
        // - 地块分割：
        //   * 大面积地块分割：面积>最大地块面积时进行分割
        //   * 基于轨迹密度分割：在轨迹稀疏区域分割地块
        //   * 保持分割后的地块形状合理性
        // - 属性计算：
        //   * 面积计算：几何面积（平方米）转换为亩（1亩=666.67平方米）
        //   * 周长计算：地块边界总长度
        //   * 形状指标：长宽比、紧凑度、分形维度
        //   * 作业效率：单位时间作业面积、作业覆盖率

        // TODO 6: 结果封装与验证
        // - SplitRoadResult对象构建：
        //   * 设置outline：合并后的作业区域几何（WGS84坐标系）
        //   * 设置wkt：几何的WKT字符串表示
        //   * 设置totalWidthM：传入的幅宽参数
        // - 作业地块列表：
        //   * 每个地块的几何、面积、周长、起止时间
        //   * 地块ID、地块类型（主作业区/边界区/连接区）
        //   * 地块质量评分（基于轨迹密度、几何规则性）
        // - 轨迹段信息：
        //   * 作业轨迹段列表（起止点、轨迹点数、段长度）
        //   * 道路轨迹段列表（用于验证和调试）
        //   * 每段的分类置信度、特征值（密度/熵/自交密度）
        // - 统计信息：
        //   * 总作业面积（亩）、总作业地块数
        //   * 总作业时间、平均作业效率（亩/小时）
        //   * 轨迹点总数、作业点数、道路点数
        //   * 分类准确率（基于置信度加权）
        // - 质量评估：
        //   * 数据质量等级（优秀/良好/一般/差）
        //   * 分割质量评分（0-100分）
        //   * 异常检测结果（异常点/异常段标记）
        // - 调试信息：
        //   * 特征提取中间结果（可选，用于调试）
        //   * 分类决策过程记录（可选）
        //   * 性能指标：处理时间、内存使用
        // - 错误处理与降级方案：
        //   * 异常捕获：每个主要步骤的try-catch保护
        //   * 降级处理：算法失败时返回基础缓冲区结果
        //   * 错误码定义：区分不同类型的失败原因
        //   * 日志记录：详细记录失败原因和处理过程
        // - 结果返回结构优化：
        //   1. 确保返回的作业轨迹点包含完整信息（经纬度、时间戳、是否作业点）
        //   2. 作业轮廓同时提供几何对象和WKT字符串两种格式
        //   3. 面积计算保留高精度，同时提供平方米和亩两种单位
        //   4. 提供轨迹点与轮廓的空间关系验证结果
        //   5. 确保结果数据的JSON序列化支持

        // TODO 7: 性能优化策略
        // - 并行处理优化：
        //   * 轨迹点分类并行化：使用ForkJoinPool并行计算轨迹点特征
        //   * 缓冲区生成并行化：对不同作业段并行生成缓冲区
        //   * 数据分区处理：将大规模轨迹数据分区后并行处理
        //   * 并行阈值设置：仅当数据量超过阈值（如1000点）时启用并行
        // - 内存管理优化：
        //   * 增量计算：避免一次性加载全部数据到内存
        //   * 对象复用：减少临时对象创建，特别是Geometry对象
        //   * 及时释放：不再使用的大型集合及时设置为null
        //   * 内存监控：添加内存使用监控，防止OOM异常
        // - 算法效率优化：
        //   * 空间索引优化：使用STRtree加速空间查询
        //   * 算法复杂度控制：确保核心算法复杂度不超过O(n log n)
        //   * 缓存优化：缓存频繁计算的中间结果
        //   * 提前终止：设置计算超时机制，避免长时间运行
        // - 性能监控与诊断：
        //   * 耗时统计：记录各阶段执行时间
        //   * 性能瓶颈分析：识别耗时操作
        //   * 自适应参数：根据数据规模动态调整算法参数
        //   * 降级处理：当性能不达标时提供简化版本
        // - 具体实现建议：
        //   1. 使用Java 8 Stream API进行并行处理
        //   2. 对轨迹点分类等CPU密集型任务使用并行流
        //   3. 对缓冲区生成等内存密集型任务控制并行度
        //   4. 使用对象池管理Geometry对象
        //   5. 实现数据分片处理，支持大数据量场景