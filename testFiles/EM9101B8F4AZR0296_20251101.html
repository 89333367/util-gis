<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>展示轮廓</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #mapContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #mapLoading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.3s;
        }

        .loading-text {
            font-size: 16px;
            color: #333;
            padding: 10px 20px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .wkt-input-container {
            position: absolute;
            top: 20px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            width: min(320px, 90vw);
            box-sizing: border-box;
            transition: all 0.3s;
        }

        .minimize-btn {
            position: absolute;
            top: -5px;
            right: -4px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #666;
            z-index: 1001;
            transition: background 0.2s;
        }

        .minimize-btn:hover {
            background: #e0e0e0;
        }

        .content-wrapper {
            transition: all 0.3s;
        }

        .wkt-input-container.minimized {
            width: 40px;
            height: 40px;
            padding: 0;
        }

        .wkt-input-container.minimized .content-wrapper {
            display: none;
        }

        .wkt-input-container.minimized .min-icon {
            display: none;
        }

        .wkt-input-container.minimized .restore-icon {
            display: inline;
        }

        #wktTextarea {
            width: 100%;
            height: 120px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        /* 页签样式 */
        .tabs-header {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        .tab-btn {
            flex: 1;
            padding: 6px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #f5f5f5;
            color: #333;
            transition: background 0.2s;
        }
        .tab-btn.active { background: #337AFF; color: #fff; }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }

        /* Multi → Polygons 分割器样式 */
        .split-section {
            margin-top: 10px;
            padding: 10px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 6px;
        }
        .split-section .title {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
        }
        .split-section .desc {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }
        #multiInput, #polyOutput {
            width: 100%;
            height: 90px;
            margin-bottom: 8px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        }
        .split-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        .split-actions button {
            flex: 1;
            padding: 6px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        #splitMultiBtn { background: #337AFF; color: #fff; }
        #splitMultiBtn:hover { background: #2860E0; }
        #copyPolysBtn { background: #f5f5f5; color: #333; }
        #copyPolysBtn:hover { background: #e0e0e0; }
        #drawButton,
        #clearButton,
        #drawTrackButton,
        #clearTrackButton {
            width: 50%;
            padding: 8px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        #drawButton,
        #drawTrackButton {
            background: #337AFF;
            color: white;
        }

        #drawButton:hover,
        #drawTrackButton:hover {
            background: #2860E0;
        }

        #clearButton,
        #clearTrackButton {
            background: #f5f5f5;
            color: #333;
        }

        #clearButton:hover,
        #clearTrackButton:hover {
            background: #e0e0e0;
        }

        #drawButton:disabled,
        #clearButton:disabled,
        #drawTrackButton:disabled,
        #clearTrackButton:disabled {
            background: #e0e0e0;
            color: #999;
            cursor: not-allowed;
        }

        .tip {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .area-label {
             position: absolute;
             background: rgba(255, 0, 0, 0.85);
             border: 1px solid #000;
             border-radius: 3px;
             padding: 4px 6px;
             font-size: 12px;
             color: #fff;
             font-weight: 600;
             box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
             white-space: nowrap;
             z-index: 9999;
             pointer-events: none;
         }
         /* 默认隐藏标签容器下的标签 */
          .labels-hidden .area-label { display: none; }

          /* Batch → Generator 样式 */
          .batch-section { margin-top: 10px; padding: 10px; background: #fafafa; border: 1px solid #eee; border-radius: 6px; }
          .batch-section .title { font-size: 13px; font-weight: 600; color: #333; margin-bottom: 6px; }
          .batch-section .desc { font-size: 12px; color: #666; margin-bottom: 8px; }
          #batchInput, #multiOutput { width: 100%; height: 90px; margin-bottom: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; resize: vertical; box-sizing: border-box; }
          .batch-actions { display: flex; gap: 8px; margin-bottom: 8px; }
          .batch-actions button { flex: 1; padding: 6px 0; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; transition: background 0.2s; }
          #generateMultiBtn { background: #337AFF; color: #fff; }
          #generateMultiBtn:hover { background: #2860E0; }
          #copyMultiBtn { background: #f5f5f5; color: #333; }
          #copyMultiBtn:hover { background: #e0e0e0; }
          
          /* 左侧工具条样式 */
          #leftToolbar {
              position: absolute;
              bottom: 20px;
              left: 20px;
              z-index: 1000;
              background: white;
              border-radius: 4px;
              box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);
              padding: 6px 0;
              display: flex;
              flex-direction: column;
              gap: 2px;
              width: 40px;
          }
          
          .toolbar-btn {
              width: 100%;
              padding: 6px 0;
              border: none;
              background: transparent;
              cursor: pointer;
              font-size: 12px;
              color: #333;
              transition: background 0.2s;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
          }
          
          .toolbar-btn:hover {
              background: #f5f5f5;
          }
          
          .toolbar-btn span {
              font-size: 12px;
              margin-top: 4px;
          }
          
          .toolbar-divider {
            height: 1px;
            background-color: #e0e0e0;
            margin: 2px 4px;
        }
        
        /* 颜色选择器样式 */
        .color-picker-container {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        
        .color-picker-title {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }
        
        .color-picker-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .color-picker-label {
            font-size: 12px;
            color: #555;
            width: 60px;
            flex-shrink: 0;
        }
        
        .color-picker {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .color-input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
        }
        
        .opacity-slider-container {
            display: flex;
            align-items: center;
            margin-top: 8px;
        }
        
        .opacity-slider {
            flex: 1;
            margin-right: 8px;
        }
        
        .opacity-value {
            font-size: 12px;
            color: #555;
            width: 40px;
            text-align: right;
        }
      </style>
    <script src="https://api.tianditu.gov.cn/api?v=4.0&tk=648f621977051d0199ff0f965d3fd322"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://lib.baomitu.com/terraformer/1.0.12/terraformer.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://unpkg.com/terraformer-wkt-parser@1.2.1/terraformer-wkt-parser.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- 已移除动态备用加载器 ensureTerraformer：改为仅使用静态脚本标签加载 Terraformer 核心库与 WKT 解析器 -->
    <script>
        // 检查Turf.js是否加载成功
        window.addEventListener('load', function () {
            if (typeof turf === 'undefined') {
                console.warn('Turf.js加载失败，已启用备用面积算法');
            } else {
                console.log('Turf.js加载成功');
            }
        });
    </script>
</head>

<body>
<!-- 左侧工具条 -->
<div id="leftToolbar">
    <button class="toolbar-btn" id="measureDistanceBtn" title="测距">
        <span>测距</span>
    </button>
    <div class="toolbar-divider"></div>
    <button class="toolbar-btn" id="measureAreaBtn" title="测面">
        <span>测面</span>
    </button>
    <div class="toolbar-divider"></div>
    <button class="toolbar-btn" id="mapTypeBtn" title="切换地图类型">
        <span>地图</span>
    </button>
</div>

<div id="mapContainer">
    <div id="mapLoading">
        <div class="loading-text">地图正在加载中...</div>
    </div>
</div>

<div class="wkt-input-container">
    <div class="minimize-btn" id="minimizeBtn">
        <span class="min-icon">−</span>
        <span class="restore-icon" style="display:none;">+</span>
    </div>

    <div class="content-wrapper">
        <div class="tabs-header">
            <button class="tab-btn active" id="tabDrawBtn">轮廓</button>
            <button class="tab-btn" id="tabTrackBtn">轨迹</button>
            <button class="tab-btn" id="tabSplitBtn">分割器</button>
            <button class="tab-btn" id="tabBatchBtn">合并器</button>
        </div>
        <div class="tab-pane active" id="tabDraw">
            <div class="tip">请输入WKT字符串（支持POLYGON/MULTIPOLYGON）：</div>
            <textarea id="wktTextarea">POLYGON ((124.528388885671 45.2879493081868, 124.52838535001823 45.28792161227648, 124.52842274522322 45.28785950951638, 124.52857685377231 45.287824710684575, 124.52857972066245 45.28782383645498, 124.52858229085176 45.28782258421587, 124.52858446556928 45.28782100209007, 124.52858616124176 45.28781915087783, 124.52858731270557 45.28781710172022, 124.52858787571071 45.28781493336523, 124.52858782862113 45.287812729141535, 124.52858758257423 45.28781191994647, 124.52872542073483 45.287775836471866, 124.52888725291335 45.287752008419545, 124.52889023284585 45.28775134892735, 124.52889297325349 45.28775029173156, 124.52889536882387 45.28774887745967, 124.52889732749655 45.28774716046136, 124.52889877400092 45.28774520671991, 124.52889965274863 45.28774309131658, 124.52889992996995 45.28774089554511, 124.52889959501152 45.287738703787795, 124.52889866074568 45.2877366002726, 124.52889716307577 45.287734665836474, 124.52889515955638 45.287732974818624, 124.52889272718177 45.28773159220394, 124.52888995942659 45.287730571125486, 124.52888696265417 45.28772995082272, 124.52888385202877 45.28772975513353, 124.52888074708983 45.2877299915781, 124.52871774711984 45.287753991573105, 124.52871546072386 45.28775445634092, 124.52843651989511 45.28782747765746, 124.5284355884008 45.287826130382186, 124.52843377119412 45.28782442272049, 124.52843152937969 45.287822988384725, 124.52842894382366 45.28782187911395, 124.52842610779166 45.28782113492152, 124.52842312358442 45.28782078265177, 124.52842009884753 45.28782083501168, 124.52841714268861 45.28782129011258, 124.52824014271818 45.28786129010471, 124.5282373207443 45.28786214740241, 124.52823478436723 45.28786337112515, 124.52823262791667 45.28786491576182, 124.52823093159266 45.28786672386633, 124.5282297584826 45.28786872819398, 124.52822915221542 45.28787085420242, 124.52822913533865 45.287873022823874, 124.52822970848004 45.28787515340578, 124.52823085032408 45.28787716671028, 124.52823251840483 45.28787898786109, 124.52823465068523 45.28788054912833, 124.5282371678642 45.28788179244731, 124.52823997632609 45.28788267157808, 124.52824613996123 45.28788411737154, 124.52824624386504 45.28788566017357, 124.52824703247477 45.28788785085383, 124.5282484257804 45.28788988595759, 124.52825036749155 45.28789168326564, 124.52825277916219 45.28789317016578, 124.5282555633596 45.287894286586486, 124.52825860760076 45.28789498742372, 124.52832351971696 45.28790497390305, 124.52832450231844 45.28790551191795, 124.52832726240825 45.28790649068366, 124.52833023819231 45.28790707507157, 124.52833331780148 45.28790724311268, 124.52833638546349 45.28790698848978, 124.52833932585531 45.28790632077498, 124.5283420284383 45.28790526506976, 124.52834439161379 45.28790386106145, 124.52834546694483 45.28790291655247, 124.5283523708066 45.28791386750308, 124.52835289951327 45.287918009054735, 124.52835133876046 45.28792060101371, 124.52835040048674 45.287922718903125, 124.52835006963966 45.287924925615734, 124.52835035910203 45.287927135224784, 124.52835729758779 45.287952460746006, 124.52836413356006 45.288006009269935, 124.52836424595817 45.2880066701973, 124.52837227103124 45.28804438809632, 124.52837126572715 45.288045724276195, 124.52837036713893 45.288047835523486, 124.52837006931274 45.288050029950384, 124.52837038369405 45.288052223226295, 124.52837238369217 45.288059223226604, 124.52837329819963 45.288061331065144, 124.52837477768912 45.28806327246327, 124.52837676530491 45.288064972814105, 124.52837750105449 45.28806539673037, 124.5283773197475 45.28806563266115, 124.52837639480074 45.28806773822881, 124.52837606955303 45.28806993071506, 124.52837635650351 45.28807212586389, 124.52837935650065 45.28808312586433, 124.52838021496108 45.28808516873302, 124.52838026170092 45.288085742681275, 124.5283821664561 45.288094314091516, 124.52838206930018 45.288095029948714, 124.5283823836812 45.288097223224646, 124.52838438367941 45.28810422322494, 124.52838474013498 45.288105044815495, 124.52838504573755 45.288105876552585, 124.5283851966281 45.28810609698141, 124.52838529818709 45.288106331063574, 124.52838587486113 45.288107087779494, 124.528386404463 45.28810786144954, 124.52838661337552 45.28810805686352, 124.52838677767747 45.28810827246183, 124.52838755240818 45.28810893522244, 124.5283882856575 45.28810962109422, 124.52838854456323 45.288109783983536, 124.52838876529438 45.288109972812855, 124.52838970830967 45.28811051614893, 124.5283906170278 45.28811108786447, 124.52839091597747 45.28811121196947, 124.52839118465499 45.2881113667731, 124.52839225971543 45.288111769804495, 124.52839330898074 45.28811220539309, 124.52839363648563 45.28811228594443, 124.52839394278456 45.2881124007734, 124.52839510857561 45.28811264801171, 124.52839625806587 45.28811293073408, 124.52839660154045 45.28811296463626, 124.5283969336897 45.28811303507771, 124.52839814541086 45.288113117021794, 124.52839935095159 45.28811323601296, 124.52839969719601 45.2881132219631, 124.52840004243153 45.28811324531004, 124.5284012535172 45.288113158810866, 124.52840246877994 45.28811310949804, 124.52840280448842 45.28811304803608, 124.52840314954277 45.2881130233913, 124.52840431345152 45.288112771772944, 124.52840549173445 45.28811255605123, 124.52840580400573 45.28811244953909, 124.5284061356188 45.28811237784968, 124.52840720762217 45.288111970781756, 124.52840830364455 45.28811159694117, 124.52840858047838 45.28811144947204, 124.52840888590632 45.288111333493006, 124.52840982480765 45.28811078661906, 124.5284107964502 45.28811026902594, 124.52841102720792 45.288110086267, 124.52841129471337 45.28810993045537, 124.5284120644317 45.28810926479115, 124.52841287435417 45.28810862333663, 124.52841305016773 45.28810841231133, 124.5284132694708 45.28810822265469, 124.52841384042621 45.28810746378115, 124.52841445750374 45.28810672311617, 124.52841457161696 45.28810649193395, 124.5284147342897 45.28810627572086, 124.5284150845402 45.28810545280178, 124.52841548505951 45.28810464138896, 124.5284155330871 45.28810439893396, 124.52841563287805 45.28810416447346, 124.52841574896408 45.28810330913302, 124.52841591753308 45.28810245815467, 124.52841589762924 45.28810221374437, 124.52841593070367 45.28810197004655, 124.52841586214588 45.288101491756, 124.52841593075982 45.288100999998214, 124.52841593075959 45.2880999999982, 124.52841562465404 45.288097806139085, 124.5284147319911 45.28809572890879, 124.52841173829997 45.288082257314336, 124.5284109542579 45.288080123443834, 124.5284107720083 45.288079857204124, 124.52841064350007 45.2880788741313, 124.52840764349715 45.288067874131755, 124.5284067553748 45.288065760678926, 124.52840530021182 45.28806381014082, 124.52840333392935 45.28806209747549, 124.52840248895158 45.28806160179147, 124.52840273427894 45.288061275719386, 124.52840276411477 45.28806120561955, 124.52840348504681 45.28806124013643, 124.5284065822206 45.28806095736351, 124.52840954173165 45.28806025350516, 124.52841224984743 45.28805915561024, 124.52841460249665 45.288057705870266, 124.5284165092683 45.28805595999796, 124.52841789688627 45.288053985086265, 124.5284187120251 45.288051857029885, 124.5284189233597 45.28804965760892, 124.52841852276848 45.28804747134582, 124.52840158682031 45.28799566731239, 124.528388885671 45.2879493081868), (124.52837095360694 45.287888026408986, 124.52836166999191 45.28787330067903, 124.52838267702943 45.287868557165254, 124.52837095360694 45.287888026408986))</textarea>
            <div class="coord-settings" style="margin-bottom:8px;font-size:12px;color:#333;">
                <label>WKT坐标系：
                    <select id="coordSysSelect" style="margin-left:6px;">
                        <option value="wgs84" selected>WGS84</option>
                        <option value="gcj02">GCJ-02（国测局）</option>
                        <option value="bd09">BD-09（百度）</option>
                        <option value="cgcs2000">CGCS2000</option>
                    </select>
                </label>
                <!-- 已移除“不进行绘制坐标转换”选项，统一使用WGS84绘制 -->
            </div>

            <div class="button-group">
                <button id="drawButton">绘制轮廓</button>
                <button id="clearButton">清空轮廓</button>
            </div>
            <!-- 显示开关：仅保留显示亩数 -->
            <div class="display-toggles" style="margin-top:8px;font-size:12px;color:#333;">
                <label><input type="checkbox" id="toggleLabelsCheckbox"> 显示亩数</label>
            </div>
            <!-- 颜色选择器 -->
            <div class="color-picker-container" style="margin-top:8px;">
                <div style="margin-bottom:6px;font-size:12px;color:#333;">轮廓颜色设置：</div>
                <div style="display:flex;align-items:center;gap:8px;">
                    <div style="display:flex;align-items:center;gap:4px;">
                        <label style="font-size:12px;">边框颜色:</label>
                        <div id="outlineColorPicker" class="color-picker" style="width:24px;height:24px;border:1px solid #ccc;cursor:pointer;background-color:#FFD700;"></div>
                        <input type="color" id="outlineColorInput" value="#FFD700" style="display:none;">
                    </div>
                    <div style="display:flex;align-items:center;gap:4px;">
                        <label style="font-size:12px;">填充颜色:</label>
                        <div id="fillColorPicker" class="color-picker" style="width:24px;height:24px;border:1px solid #ccc;cursor:pointer;background-color:#FFFF00;"></div>
                        <input type="color" id="fillColorInput" value="#FFFF00" style="display:none;">
                    </div>
                    <div style="display:flex;align-items:center;gap:4px;">
                        <label style="font-size:12px;">透明度:</label>
                        <input type="range" id="fillOpacitySlider" min="0" max="100" value="35" style="width:60px;">
                        <span id="fillOpacityValue" style="font-size:12px;">35%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-pane" id="tabSplit">
            <!-- MultiPolygon → 多个 Polygon 分割器 -->
            <div class="split-section">
                <div class="title">MultiPolygon → 多个 Polygon 分割器</div>
                <div class="desc">输入一个 MULTIPOLYGON WKT，分割为多行 POLYGON WKT。</div>
                <textarea id="multiInput"></textarea>
                <div class="split-actions">
                    <button id="splitMultiBtn">分割为多个 POLYGON</button>
                    <button id="copyPolysBtn">复制结果</button>
                </div>
                <textarea id="polyOutput" readonly></textarea>
            </div>
        </div>

        <div class="tab-pane" id="tabBatch">
            <!-- 批量POLYGON → MULTIPOLYGON 生成器 -->
            <div class="batch-section">
                <div class="title">批量POLYGON → MULTIPOLYGON 合并器</div>
                <div class="desc">每行一个 POLYGON WKT（或用分号分隔）。生成后可一键填充到上方并绘制。</div>
                <textarea id="batchInput"></textarea>
                <div class="batch-actions">
                    <button id="generateMultiBtn">生成 MULTIPOLYGON</button>
                    <button id="copyMultiBtn">复制结果</button>
                </div>
                <textarea id="multiOutput" readonly></textarea>
            </div>
        </div>
        <div class="tab-pane" id="tabTrack">
            <div class="tip">请粘贴轨迹文本（支持两种格式：1）每行一条：定位时间yyyyMMddHHmmss, 经度, 纬度；2）单行#分隔：经度,纬度,定位时间yyyyMMddHHmmss#经度,纬度,定位时间yyyyMMddHHmmss#…）。</div>
            <div class="coord-settings" style="margin-bottom:8px;font-size:12px;color:#333;">
                <label>轨迹坐标系：
                    <select id="trackCoordSysSelect" style="margin-left:6px;">
                        <option value="wgs84" selected>WGS84</option>
                        <option value="gcj02">GCJ-02（国测局）</option>
                        <option value="bd09">BD-09（百度）</option>
                        <option value="cgcs2000">CGCS2000</option>
                    </select>
                </label>
            </div>
            <textarea id="trackTextarea" style="width:100%;height:120px;margin-bottom:10px;padding:8px;border:1px solid #ddd;border-radius:4px;font-family:monospace;resize:vertical;box-sizing:border-box;">20251101075920,124.504387,45.342025
20251101075930,124.504243,45.341985
20251101075940,124.503652,45.341865
20251101075950,124.503114,45.341694
20251101080000,124.502817,45.341689
20251101080010,124.502542,45.342064
20251101080020,124.502319,45.342370
20251101080030,124.502012,45.342488
20251101080040,124.501846,45.342633
20251101080050,124.501788,45.342669
20251101080100,124.501646,45.342732
20251101080110,124.501523,45.342723
20251101080120,124.501176,45.342718
20251101080130,124.500875,45.343054
20251101080140,124.500348,45.343603
20251101080150,124.499824,45.344164
20251101080200,124.499290,45.344746
20251101080210,124.498757,45.345367
20251101080220,124.498242,45.346002
20251101080230,124.498049,45.346552
20251101080240,124.498454,45.347215
20251101080250,124.498625,45.347900
20251101080300,124.498718,45.348550
20251101080310,124.498712,45.349030
20251101080320,124.498683,45.349368
20251101080330,124.498661,45.349797
20251101080340,124.498705,45.350375
20251101080350,124.498759,45.350973
20251101080400,124.498891,45.351561
20251101080410,124.499311,45.352187
20251101080420,124.499783,45.352811
20251101080430,124.500162,45.353467
20251101080440,124.500426,45.354135
20251101080450,124.500667,45.354797
20251101080500,124.500919,45.355480
20251101080510,124.501238,45.356100
20251101080520,124.501516,45.356662
20251101080530,124.502005,45.357202
20251101080540,124.502457,45.357825
20251101080550,124.503042,45.358306
20251101080600,124.503482,45.358779
20251101080610,124.503445,45.359374
20251101080620,124.502929,45.359970
20251101080630,124.502588,45.360376
20251101080640,124.502270,45.360729
20251101080650,124.501726,45.361076
20251101080700,124.500976,45.361247
20251101080710,124.500589,45.361714
20251101080720,124.500417,45.361975
20251101080730,124.500417,45.361975
20251101080740,124.500417,45.361975
20251101080750,124.500449,45.362271
20251101080800,124.500499,45.362833
20251101080810,124.500068,45.363417
20251101080820,124.499644,45.364001
20251101080830,124.499411,45.364590
20251101080840,124.499554,45.365230
20251101080850,124.499694,45.365896
20251101080900,124.499833,45.366570
20251101080910,124.499944,45.367253
20251101080920,124.500061,45.367948
20251101080930,124.500115,45.368659
20251101080940,124.500155,45.369365
20251101080950,124.500193,45.370064
20251101081000,124.500244,45.370756
20251101081010,124.500307,45.371430
20251101081020,124.500262,45.372102
20251101081030,124.500196,45.372771
20251101081040,124.500134,45.373423
20251101081050,124.500144,45.374126
20251101081100,124.500240,45.374770
20251101081110,124.500294,45.375217
20251101081120,124.500365,45.375874
20251101081130,124.500447,45.376537
20251101081140,124.500535,45.377228
20251101081150,124.500630,45.377986
20251101081200,124.500784,45.378614
20251101081210,124.501194,45.379199
20251101081220,124.501645,45.379842
20251101081230,124.502068,45.380447
20251101081240,124.502493,45.381046
20251101081250,124.502891,45.381609
20251101081300,124.503302,45.382187
20251101081310,124.503600,45.382441
20251101081320,124.503926,45.382531
20251101081330,124.504207,45.382582
20251101081340,124.504570,45.382658
20251101081350,124.505059,45.382744
20251101081400,124.505430,45.382800
20251101081410,124.505762,45.382875
20251101081420,124.506188,45.382954
20251101081430,124.506715,45.383047
20251101081440,124.507192,45.383131
20251101081450,124.507660,45.383217
20251101081500,124.508172,45.383308
20251101081510,124.508597,45.383372
20251101081520,124.509106,45.383430
20251101081530,124.509567,45.383394
20251101081540,124.510021,45.383267
20251101081550,124.510438,45.383130
20251101081600,124.510830,45.383138
20251101081610,124.511053,45.383408
20251101081620,124.511427,45.383662
20251101081630,124.511546,45.383968
20251101081640,124.511356,45.384340
20251101081650,124.511029,45.384728
20251101081700,124.510651,45.384979
20251101081710,124.510239,45.385218
20251101081720,124.509849,45.385446
20251101081730,124.509456,45.385643
20251101081740,124.509032,45.385848
20251101081750,124.508629,45.386040
20251101081800,124.508664,45.386310
20251101081810,124.508945,45.386580
20251101081820,124.509232,45.386872
20251101081830,124.509559,45.387189
20251101081840,124.509807,45.387434
20251101081850,124.510050,45.387673
20251101081900,124.510291,45.387929
20251101081910,124.510566,45.388259
20251101081920,124.510837,45.388605
20251101081930,124.511089,45.388948
20251101081940,124.511356,45.389222
20251101081950,124.511606,45.389476
20251101082000,124.511907,45.389816
20251101082010,124.512154,45.390083
20251101082020,124.512417,45.390375
20251101082030,124.512677,45.390665
20251101082040,124.512942,45.390963
20251101082050,124.513195,45.391234
20251101082100,124.513431,45.391504
20251101082110,124.513675,45.391788
20251101082120,124.513920,45.392063
20251101082130,124.513871,45.392323
20251101082140,124.513741,45.392482
20251101082150,124.513608,45.392674
20251101082200,124.513414,45.392915
20251101082210,124.513200,45.393177
20251101082220,124.512980,45.393415
20251101082230,124.512807,45.393601
20251101082240,124.512807,45.393602
20251101082250,124.512807,45.393602
20251101082300,124.512781,45.393632
20251101082310,124.512682,45.393738
20251101082320,124.512682,45.393738
20251101082330,124.512682,45.393739
20251101082340,124.512682,45.393739
20251101082350,124.512575,45.393876
20251101082400,124.512463,45.394155
20251101082410,124.512390,45.394477
20251101082420,124.512315,45.394803
20251101082430,124.512192,45.395132
20251101082440,124.512060,45.395461
20251101082450,124.511930,45.395780
20251101082500,124.511831,45.396085
20251101082510,124.511842,45.396425
20251101082520,124.511890,45.396711
20251101082530,124.512010,45.397040
20251101082540,124.512217,45.397352
20251101082550,124.512419,45.397644
20251101082600,124.512632,45.397943
20251101082610,124.512963,45.398172
20251101082620,124.513276,45.398298
20251101082630,124.513534,45.398390
20251101082640,124.513679,45.398461
20251101082650,124.513929,45.398562
20251101082700,124.514194,45.398556
20251101082710,124.514389,45.398356
20251101082720,124.514358,45.398177
20251101082730,124.514533,45.398056
20251101082740,124.514634,45.397977
20251101082750,124.514635,45.397977
20251101082800,124.514635,45.397977
20251101082810,124.514635,45.397977
20251101082820,124.514658,45.397962
20251101082830,124.514721,45.397919
20251101082840,124.514748,45.397902
20251101082850,124.514788,45.397878
20251101082900,124.514790,45.397877
20251101082910,124.514790,45.397877
20251101082920,124.514790,45.397877
20251101082930,124.514790,45.397877
20251101082940,124.514790,45.397877
20251101082950,124.514790,45.397877
20251101083000,124.514790,45.397877
20251101083010,124.514790,45.397877
20251101083020,124.514790,45.397877
20251101083030,124.514790,45.397877
20251101083040,124.514790,45.397877
20251101083050,124.514790,45.397877
20251101083100,124.514838,45.397849
20251101083110,124.514908,45.397808
20251101083120,124.514982,45.397764
20251101083130,124.515057,45.397720
20251101083140,124.515135,45.397673
20251101083150,124.515204,45.397630
20251101083200,124.515263,45.397593
20251101083210,124.515327,45.397552
20251101083220,124.515399,45.397508
20251101083230,124.515473,45.397463
20251101083240,124.515536,45.397422
20251101083250,124.515610,45.397372
20251101083300,124.515694,45.397317
20251101083310,124.515779,45.397260
20251101083320,124.515864,45.397203
20251101083330,124.515941,45.397150
20251101083340,124.516022,45.397098
20251101083350,124.516113,45.397044
20251101083400,124.516205,45.396994
20251101083410,124.516298,45.396945
20251101083420,124.516392,45.396894
20251101083430,124.516485,45.396842
20251101083440,124.516587,45.396785
20251101083450,124.516682,45.396732
20251101083500,124.516783,45.396675
20251101083510,124.516891,45.396616
20251101083520,124.516984,45.396557
20251101083530,124.517065,45.396516
20251101083540,124.517158,45.396466
20251101083550,124.517251,45.396417
20251101083600,124.517342,45.396369
20251101083610,124.517430,45.396321
20251101083620,124.517525,45.396270
20251101083630,124.517617,45.396222
20251101083640,124.517708,45.396173
20251101083650,124.517797,45.396126
20251101083700,124.517874,45.396085
20251101083710,124.517955,45.396039
20251101083720,124.518035,45.395995
20251101083730,124.518000,45.396016
20251101083740,124.518000,45.396015
20251101083750,124.518000,45.396015
20251101083800,124.518001,45.396015
20251101083810,124.518001,45.396015
20251101083820,124.518025,45.396001
20251101083830,124.518104,45.395955
20251101083840,124.518180,45.395912
20251101083850,124.518194,45.395906
20251101083900,124.518192,45.395907
20251101083910,124.518192,45.395907
20251101083920,124.518192,45.395907
20251101083930,124.518192,45.395907
20251101083940,124.518192,45.395907
20251101083950,124.518192,45.395907
20251101084000,124.518192,45.395907
20251101084010,124.518192,45.395907
20251101084020,124.518192,45.395907
20251101084030,124.518192,45.395907
20251101084040,124.518192,45.395907
20251101084050,124.518192,45.395907
20251101084100,124.518251,45.395873
20251101084110,124.518305,45.395844
20251101084120,124.518345,45.395822
20251101084130,124.518421,45.395779
20251101084140,124.518500,45.395736
20251101084150,124.518582,45.395689
20251101084200,124.518664,45.395642
20251101084210,124.518749,45.395595
20251101084220,124.518782,45.395577
20251101084230,124.518807,45.395562
20251101084240,124.518890,45.395515
20251101084250,124.518976,45.395468
20251101084300,124.519052,45.395425
20251101084310,124.519131,45.395380
20251101084320,124.519212,45.395334
20251101084330,124.519297,45.395286
20251101084340,124.519383,45.395237
20251101084350,124.519466,45.395190
20251101084400,124.519552,45.395141
20251101084410,124.519644,45.395089
20251101084420,124.519736,45.395037
20251101084430,124.519745,45.395032
20251101084440,124.519764,45.395022
20251101084450,124.519767,45.395021
20251101084500,124.519769,45.395020
20251101084510,124.519768,45.395020
20251101084520,124.519768,45.395020
20251101084530,124.519768,45.395020
20251101084540,124.519768,45.395020
20251101084550,124.519768,45.395020
20251101084600,124.519768,45.395020
20251101084610,124.519768,45.395020
20251101084620,124.519768,45.395020
20251101084630,124.519768,45.395020
20251101084640,124.519768,45.395020
20251101084650,124.519768,45.395020
20251101084700,124.519768,45.395020
20251101084710,124.519768,45.395020
20251101084720,124.519768,45.395020
20251101084730,124.519768,45.395020
20251101084740,124.519768,45.395020
20251101084750,124.519768,45.395020
20251101084800,124.519768,45.395020
20251101084810,124.519768,45.395020
20251101084820,124.519768,45.395020
20251101084830,124.519768,45.395020
20251101084840,124.519768,45.395020
20251101084850,124.519768,45.395020
20251101084900,124.519768,45.395020
20251101084910,124.519768,45.395020
20251101084920,124.519768,45.395020
20251101090657,124.519693,45.395061
20251101090707,124.519693,45.395061
20251101090717,124.519680,45.395068
20251101090727,124.519703,45.395055
20251101090737,124.519771,45.395114
20251101090747,124.519564,45.395278
20251101090757,124.519204,45.395480
20251101090807,124.518844,45.395682
20251101090817,124.518486,45.395885
20251101090827,124.518284,45.396022
20251101090837,124.518024,45.396165
20251101090847,124.517668,45.396346
20251101090857,124.517304,45.396544
20251101090907,124.517048,45.396680
20251101090917,124.516794,45.396809
20251101090927,124.516467,45.396985
20251101090937,124.516104,45.397184
20251101090947,124.515767,45.397406
20251101090957,124.515428,45.397622
20251101091007,124.515079,45.397834
20251101091017,124.514749,45.397971
20251101091027,124.514556,45.398046
20251101091037,124.514329,45.398212
20251101091047,124.514298,45.398239
20251101091057,124.514388,45.398350
20251101152839,124.513965,45.398579
20251101152849,124.513823,45.398495
20251101152859,124.513664,45.398408
20251101152909,124.513498,45.398350
20251101152919,124.513269,45.398294
20251101152929,124.513143,45.398263
20251101152939,124.512917,45.398139
20251101152949,124.512689,45.397986
20251101152959,124.512529,45.397794
20251101153009,124.512383,45.397578
20251101153019,124.512252,45.397393
20251101153029,124.512144,45.397237
20251101153039,124.512045,45.397079
20251101153049,124.511950,45.396897
20251101153059,124.511900,45.396706
20251101153109,124.511864,45.396515
20251101153119,124.511840,45.396331
20251101153129,124.511833,45.396131
20251101153139,124.511873,45.395962
20251101153149,124.511950,45.395742
20251101153159,124.512030,45.395542
20251101153209,124.512113,45.395347
20251101153219,124.512182,45.395171
20251101153229,124.512333,45.394773
20251101153239,124.512406,45.394431
20251101153249,124.512481,45.394130
20251101153259,124.512563,45.393915
20251101153309,124.512591,45.393701
20251101153319,124.512830,45.393567
20251101153329,124.512969,45.393448
20251101153339,124.513215,45.393174
20251101153349,124.513508,45.392831
20251101153359,124.513742,45.392495
20251101153409,124.513966,45.392224
20251101153419,124.513828,45.391949
20251101153429,124.513558,45.391648
20251101153439,124.513323,45.391372
20251101153449,124.513080,45.391102
20251101153459,124.512807,45.390811
20251101153509,124.512623,45.390597
20251101153519,124.512380,45.390326
20251101153529,124.512125,45.390039
20251101153539,124.511879,45.389773
20251101153549,124.511566,45.389422
20251101153559,124.511284,45.389142
20251101153609,124.510995,45.388806
20251101153619,124.510728,45.388460
20251101153629,124.510399,45.388044
20251101153639,124.510060,45.387673
20251101153649,124.509868,45.387487
20251101153659,124.509858,45.387475
20251101153709,124.509858,45.387475
20251101153719,124.509847,45.387464
20251101153729,124.509730,45.387345
20251101153739,124.509569,45.387196
20251101153749,124.509423,45.387058
20251101153759,124.509278,45.386911
20251101153809,124.509013,45.386644
20251101153819,124.508786,45.386422
20251101153829,124.508585,45.386160
20251101153839,124.508898,45.385917
20251101153849,124.509260,45.385741
20251101153859,124.509721,45.385517
20251101153909,124.510155,45.385271
20251101153919,124.510571,45.385030
20251101153929,124.510983,45.384766
20251101153939,124.511303,45.384437
20251101153949,124.511538,45.384003
20251101153959,124.511376,45.383620
20251101154009,124.511023,45.383377
20251101154019,124.510820,45.383119
20251101154029,124.510510,45.383099
20251101154039,124.510239,45.383191
20251101154049,124.509824,45.383315
20251101154059,124.509371,45.383423
20251101154109,124.508881,45.383403
20251101154119,124.508387,45.383336
20251101154129,124.508129,45.383296
20251101154139,124.508016,45.383276
20251101154149,124.507587,45.383197
20251101154159,124.507125,45.383115
20251101154209,124.506622,45.383027
20251101154219,124.506188,45.382949
20251101154229,124.505740,45.382869
20251101154239,124.505449,45.382799
20251101154249,124.505177,45.382755
20251101154259,124.504851,45.382704
20251101154309,124.504395,45.382617
20251101154319,124.504129,45.382560
20251101154541,124.503101,45.381889
20251101154551,124.502672,45.381279
20251101154601,124.502319,45.380785
20251101154611,124.502218,45.380636
20251101154621,124.502030,45.380404
20251101154631,124.501852,45.380125
20251101154641,124.501499,45.379611
20251101154651,124.501152,45.379119
20251101154701,124.500821,45.378649
20251101154711,124.500661,45.378198
20251101154721,124.500608,45.377700
20251101154731,124.500527,45.377076
20251101154741,124.500455,45.376484
20251101154751,124.500381,45.375952
20251101154801,124.500321,45.375411
20251101154811,124.500244,45.374846
20251101154821,124.500171,45.374258
20251101154831,124.500111,45.373706
20251101154841,124.500179,45.373140
20251101154851,124.500235,45.372504
20251101154901,124.500293,45.371916
20251101154911,124.500311,45.371328
20251101154921,124.500248,45.370736
20251101154931,124.500198,45.370091
20251101154941,124.500159,45.369441
20251101154951,124.500128,45.368772
20251101155001,124.500088,45.368104
20251101155011,124.499980,45.367423
20251101155021,124.499860,45.366724
20251101155031,124.499721,45.366036
20251101155041,124.499580,45.365401
20251101155051,124.499448,45.364780
20251101155101,124.499556,45.364121
20251101155111,124.499959,45.363576
20251101155121,124.500328,45.363082
20251101155131,124.500556,45.362562
20251101155141,124.500405,45.362014
20251101155151,124.500770,45.361489
20251101155201,124.501328,45.361113
20251101155211,124.502113,45.360889
20251101155221,124.502584,45.360370
20251101155231,124.503069,45.359827
20251101155241,124.503501,45.359261
20251101155251,124.503462,45.358694
20251101155301,124.503007,45.358283
20251101155311,124.502671,45.358018
20251101155321,124.502345,45.357680
20251101155331,124.502105,45.357325
20251101155341,124.501863,45.357046
20251101155351,124.501862,45.357045
20251101155401,124.501817,45.356996
20251101155411,124.501575,45.356708
20251101155421,124.501570,45.356703
20251101155431,124.501570,45.356703
20251101155441,124.501570,45.356702
20251101155451,124.501550,45.356679
20251101155501,124.501409,45.356486
20251101155511,124.501303,45.356277
20251101155521,124.501171,45.355939
20251101155531,124.501006,45.355657
20251101155541,124.501007,45.355658
20251101155551,124.501003,45.355651
20251101155601,124.500864,45.355312
20251101155611,124.500676,45.354809
20251101155621,124.500440,45.354139
20251101155631,124.500187,45.353493
20251101155641,124.500022,45.353165
20251101155651,124.499854,45.352902
20251101155701,124.499695,45.352643
20251101155711,124.499442,45.352321
20251101155721,124.499125,45.351921
20251101155731,124.498817,45.351310
20251101155741,124.498764,45.350718
20251101155751,124.498696,45.350241
20251101155801,124.498684,45.349795
20251101155811,124.498686,45.349283
20251101155821,124.498725,45.348698
20251101155831,124.498686,45.348245
20251101155841,124.498586,45.347576
20251101155851,124.498219,45.346827
20251101155901,124.497990,45.346362
20251101155911,124.498513,45.345656
20251101155921,124.499028,45.345053
20251101155931,124.499698,45.344306
20251101155941,124.500377,45.343579
20251101155951,124.500785,45.343145
20251101160001,124.501054,45.342853
20251101160011,124.501324,45.342113
20251101160021,124.501038,45.341751
20251101160031,124.500502,45.341435
20251101160041,124.500038,45.340801
20251101160051,124.499916,45.340258
20251101160101,124.500333,45.339884
20251101160111,124.500860,45.339320
20251101160121,124.501142,45.338732
20251101160131,124.501351,45.338212
20251101160141,124.501654,45.337497
20251101160151,124.501936,45.336823
20251101160201,124.502037,45.336217
20251101160211,124.502389,45.335579
20251101160221,124.502888,45.335254
20251101160231,124.502688,45.334817
20251101160241,124.502451,45.334318
20251101160251,124.502105,45.333575
20251101160301,124.502065,45.332923
20251101160311,124.502027,45.332225
20251101160321,124.502017,45.331662
20251101160331,124.502147,45.331192
20251101160341,124.502350,45.330671
20251101160351,124.502548,45.330204
20251101160401,124.502687,45.329961
20251101160411,124.502996,45.329688
20251101160421,124.503343,45.329375
20251101160431,124.503706,45.329030
20251101160441,124.504146,45.328664
20251101160451,124.504532,45.328421
20251101160501,124.504871,45.328224
20251101160511,124.505191,45.328055
20251101160521,124.505472,45.327905
20251101160531,124.505748,45.327760
20251101160541,124.506077,45.327593
20251101160551,124.506652,45.327292
20251101160601,124.507170,45.327012
20251101160611,124.507925,45.326587
20251101160621,124.508660,45.326189
20251101160631,124.509447,45.325762
20251101160641,124.510298,45.325276
20251101160651,124.511140,45.324812
20251101160701,124.512008,45.324351
20251101160711,124.512719,45.323970
20251101160721,124.513418,45.323576
20251101160731,124.514072,45.323223
20251101160741,124.514682,45.322882
20251101160751,124.514790,45.322820
20251101160801,124.515021,45.322714
20251101160811,124.515789,45.322298
20251101160821,124.516551,45.321882
20251101160831,124.517294,45.321477
20251101160841,124.517999,45.321094
20251101160851,124.518287,45.320935
20251101160901,124.518287,45.320935
20251101160911,124.518287,45.320935
20251101160921,124.518678,45.320731
20251101160931,124.519416,45.320333
20251101160941,124.520144,45.319939
20251101160951,124.520794,45.319480
20251101161001,124.521330,45.318906
20251101161011,124.521799,45.318276
20251101161021,124.522212,45.317714
20251101161031,124.522594,45.317208
20251101161041,124.523008,45.316675
20251101161051,124.523422,45.316124
20251101161101,124.523833,45.315581
20251101161111,124.524280,45.314981
20251101161121,124.524670,45.314463
20251101161131,124.524968,45.314049
20251101161141,124.525126,45.313804
20251101161151,124.525341,45.313568
20251101161201,124.525777,45.313004
20251101161211,124.526156,45.312517
20251101161221,124.526615,45.311897
20251101161231,124.527023,45.311330
20251101161241,124.527291,45.310981
20251101161251,124.527708,45.310393
20251101161301,124.527973,45.310045
20251101161311,124.528106,45.309842
20251101161321,124.528476,45.309392
20251101161331,124.528845,45.309103
20251101161341,124.529249,45.308702
20251101161351,124.529736,45.308191
20251101161401,124.530205,45.307605
20251101161411,124.530501,45.306969
20251101161421,124.530651,45.306474
20251101161431,124.530844,45.305825
20251101161441,124.531027,45.305220
20251101161451,124.531195,45.304712
20251101161501,124.531343,45.304148
20251101161511,124.531562,45.303460
20251101161521,124.531756,45.302789
20251101161531,124.531969,45.302102
20251101161541,124.532124,45.301510
20251101161551,124.532185,45.301052
20251101161601,124.532192,45.301004
20251101161611,124.532290,45.300579
20251101161621,124.532426,45.299844
20251101161631,124.532557,45.299089
20251101161641,124.532689,45.298361
20251101161651,124.532816,45.297670
20251101161701,124.532930,45.297040
20251101161711,124.533054,45.296339
20251101161721,124.533190,45.295594
20251101161731,124.533340,45.294746
20251101161741,124.533476,45.293985
20251101161751,124.533609,45.293215
20251101161801,124.533758,45.292416
20251101161811,124.533900,45.291615
20251101161821,124.534008,45.291010
20251101161831,124.534054,45.290637
20251101161841,124.534121,45.290316
20251101161851,124.534230,45.289668
20251101161901,124.534361,45.289055
20251101161911,124.534523,45.288380
20251101161921,124.534631,45.287923
20251101161931,124.534676,45.287728
20251101161941,124.534760,45.287343
20251101161951,124.534821,45.287082
20251101162001,124.534832,45.286936
20251101162011,124.534769,45.286753
20251101162021,124.534391,45.286764
20251101162031,124.533663,45.286791
20251101162041,124.532673,45.287167
20251101162051,124.531712,45.287341
20251101162101,124.530573,45.287515
20251101162111,124.529538,45.287652
20251101162121,124.528572,45.287814
20251101162131,124.528262,45.287884
20251101162141,124.528327,45.287894
20251101162151,124.528321,45.287888
20251101162201,124.528333,45.287896
20251101162211,124.528329,45.287893
20251101162221,124.528326,45.287891
20251101162231,124.528245,45.287872
20251101162241,124.528422,45.287832
20251101162251,124.528366,45.287925
20251101162301,124.528386,45.287998
20251101162311,124.528389,45.288006
20251101162321,124.528400,45.288039
20251101162331,124.528403,45.288050
20251101162447,124.528398,45.288095
20251101162457,124.528400,45.288099
20251101162507,124.528400,45.288102
20251101165439,124.528388,45.288057
20251101165449,124.528386,45.288050
20251101192524,124.528386,45.288052
20251101192630,124.528392,45.288070
20251101192640,124.528393,45.288073
20251101192650,124.528394,45.288077
20251101192700,124.528395,45.288081
20251101192710,124.528395,45.288081
20251101192720,124.528395,45.288081
20251101192730,124.528395,45.288081
20251101192740,124.528395,45.288081
20251101192750,124.528395,45.288081
20251101192800,124.528396,45.288084
20251101192810,124.528397,45.288087
20251101192820,124.528397,45.288090
20251101192830,124.528398,45.288092
20251101192840,124.528398,45.288094
20251101192850,124.528398,45.288095
20251101192900,124.528398,45.288094
20251101192910,124.528399,45.288096
20251101192920,124.528399,45.288098
20251101192930,124.528399,45.288099
20251101192940,124.528400,45.288100
20251101192950,124.528400,45.288100
20251101193000,124.528400,45.288102
20251101193010,124.528400,45.288102
20251101193349,124.528400,45.288102
20251101193359,124.528400,45.288102
20251101193409,124.528400,45.288102
20251101193419,124.528400,45.288102
20251101193429,124.528400,45.288102
20251101193439,124.528400,45.288102
20251101193449,124.528400,45.288102
20251101193543,124.528400,45.288103
20251101195428,124.528400,45.288101
20251101195438,124.528400,45.288100
20251101195448,124.528400,45.288100
20251101195458,124.528400,45.288100
20251101195508,124.528400,45.288100
20251101195518,124.528400,45.288100
20251101195528,124.528400,45.288100
20251101195538,124.528400,45.288101
20251101195635,124.528400,45.288101
20251101195645,124.528400,45.288101
20251101195938,124.528390,45.288052
20251101195948,124.528389,45.288048
20251101195958,124.528389,45.288048
20251101200008,124.528389,45.288048
20251101200018,124.528380,45.288005
20251101200028,124.528376,45.287973
20251101200038,124.528371,45.287944
20251101200048,124.528368,45.287911
20251101200058,124.528339,45.287865
20251101200108,124.528721,45.287765
20251101200118,124.528884,45.287741
20251101200128,124.529518,45.287659
20251101200138,124.530373,45.287531
20251101200148,124.531181,45.287405
20251101200158,124.532024,45.287277
20251101200208,124.532828,45.287109
20251101200218,124.533553,45.286822
20251101200228,124.534486,45.286751
20251101200238,124.534792,45.286769
20251101200248,124.534824,45.286971
20251101200258,124.534799,45.287121
20251101200308,124.534722,45.287471
20251101200318,124.534605,45.288015
20251101200328,124.534467,45.288610
20251101200338,124.534330,45.289178
20251101200348,124.534228,45.289632
20251101200358,124.534124,45.290201
20251101200408,124.534031,45.290819
20251101200418,124.533903,45.291567
20251101200428,124.533780,45.292260
20251101200438,124.533651,45.292970
20251101200448,124.533524,45.293669
20251101200458,124.533401,45.294328
20251101200508,124.533293,45.294986
20251101200518,124.533172,45.295684
20251101200528,124.533046,45.296355
20251101200538,124.532922,45.297034
20251101200548,124.532809,45.297679
20251101200558,124.532677,45.298421
20251101200608,124.532540,45.299158
20251101200618,124.532415,45.299858
20251101200628,124.532288,45.300557
20251101200638,124.532165,45.301248
20251101200648,124.532040,45.301851
20251101200658,124.531980,45.302153
20251101200708,124.531917,45.302272
20251101200718,124.531791,45.302664
20251101200728,124.531600,45.303306
20251101200738,124.531394,45.303970
20251101200748,124.531224,45.304568
20251101200758,124.531045,45.305150
20251101200808,124.530839,45.305833
20251101200818,124.530651,45.306458
20251101200828,124.530487,45.307032
20251101200838,124.530192,45.307619
20251101200848,124.529809,45.308105
20251101200858,124.529348,45.308597
20251101200908,124.528904,45.309041
20251101200918,124.528390,45.309462
20251101200928,124.527997,45.309974
20251101200938,124.527604,45.310549
20251101200948,124.527211,45.311089
20251101200958,124.526782,45.311651
20251101201008,124.526381,45.312218
20251101201018,124.525907,45.312828
20251101201028,124.525455,45.313421
20251101201038,124.525058,45.313935
20251101201048,124.524644,45.314483
20251101201058,124.524234,45.315029
20251101201108,124.523832,45.315573
20251101201118,124.523388,45.316161
20251101201128,124.522958,45.316736
20251101201138,124.522549,45.317279
20251101201148,124.522148,45.317803
20251101201158,124.521751,45.318341
20251101201208,124.521434,45.318769
20251101201218,124.520932,45.319350
20251101201228,124.520299,45.319847
20251101201238,124.519487,45.320279
20251101201248,124.518697,45.320711
20251101201258,124.517933,45.321125
20251101201308,124.517155,45.321547
20251101201318,124.516437,45.321940
20251101201328,124.515689,45.322346
20251101201338,124.514987,45.322723
20251101201348,124.514217,45.323131
20251101201358,124.513463,45.323546
20251101201408,124.512710,45.323968
20251101201418,124.511908,45.324396
20251101201428,124.511103,45.324830
20251101201438,124.510320,45.325260
20251101201448,124.509592,45.325680
20251101201458,124.508887,45.326060
20251101201508,124.508233,45.326419
20251101201518,124.507599,45.326767
20251101201528,124.506983,45.327115
20251101201538,124.506223,45.327520
20251101201548,124.505502,45.327886
20251101201558,124.504870,45.328225
20251101201608,124.504201,45.328621
20251101201618,124.503583,45.329140
20251101201628,124.503026,45.329662
20251101201638,124.502551,45.330204
20251101201648,124.502313,45.330769
20251101201658,124.502133,45.331232
20251101201708,124.502008,45.331797
20251101201718,124.502045,45.332365
20251101201728,124.502053,45.333038
20251101201738,124.501965,45.333591
20251101201748,124.501581,45.334147
20251101201758,124.501349,45.334693
20251101201808,124.501165,45.335296
20251101201818,124.500921,45.335871
20251101201828,124.500702,45.336426
20251101201838,124.500434,45.336973
20251101201848,124.500134,45.337455
20251101201858,124.499939,45.337796
20251101201908,124.499635,45.338289
20251101201918,124.499314,45.338834
20251101201928,124.499142,45.339400
20251101201938,124.498965,45.339712
20251101201948,124.499256,45.339929
20251101201958,124.499848,45.340206
20251101202008,124.500194,45.340372
20251101202018,124.500866,45.340706
20251101202028,124.501572,45.341054
20251101202038,124.502243,45.341346
20251101202048,124.502848,45.341615
20251101202058,124.503607,45.341856
20251101202108,124.504329,45.341998
20251101202118,124.504526,45.342071
20251101202128,124.504475,45.342068
20251101202138,124.504406,45.342128
20251101202148,124.504407,45.342127</textarea>
            <div class="button-group">
                <button id="drawTrackButton" disabled style="flex: 1;">绘制轨迹</button>
                <button id="showTrackPointsButton" disabled style="flex: 1;" class="btn-warning">打点</button>
                <button id="clearTrackButton" disabled style="flex: 1;">清空轨迹</button>
            </div>
            <!-- 轨迹颜色选择器 -->
            <div class="color-picker-container" style="margin-top:8px;">
                <div style="margin-bottom:6px;font-size:12px;color:#333;">轨迹颜色设置：</div>
                <div style="display:flex;align-items:center;gap:8px;">
                    <div style="display:flex;align-items:center;gap:4px;">
                        <label style="font-size:12px;">轨迹线颜色:</label>
                        <div id="trackLineColorPicker" class="color-picker" style="width:24px;height:24px;border:1px solid #ccc;cursor:pointer;background-color:#FF0000;"></div>
                        <input type="color" id="trackLineColorInput" value="#FF0000" style="display:none;">
                    </div>
                    <div style="display:flex;align-items:center;gap:4px;">
                        <label style="font-size:12px;">轨迹点颜色:</label>
                        <div id="trackPointColorPicker" class="color-picker" style="width:24px;height:24px;border:1px solid #ccc;cursor:pointer;background-color:#68EAF3;"></div>
                        <input type="color" id="trackPointColorInput" value="#68EAF3" style="display:none;">
                    </div>
                </div>
            </div>
            <!-- 回放控制 -->
            <div class="split-section" style="margin-top:8px;">
                <div class="title">轨迹回放</div>
                <div class="playback-actions" style="display:flex;gap:8px;margin-bottom:8px;">
                    <button id="playbackStartBtn" disabled>开始</button>
                    <button id="playbackPauseBtn" disabled>继续</button>
                    <button id="playbackStopBtn" disabled>结束</button>
                </div>
                <div class="playback-speed" style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <label>速度：
                        <select id="playbackSpeedSelect" disabled>
                            <option value="1" selected>1×</option>
                            <option value="2">2×</option>
                            <option value="4">4×</option>
                            <option value="8">8×</option>
                            <option value="16">16×</option>
                            <option value="32">32×</option>
                            <option value="64">64×</option>
                            <option value="128">128×</option>
                            <option value="256">256×</option>
                            <option value="512">512×</option>
                            <option value="1024">1024×</option>
                        </select>
                    </label>
                    <span id="playbackTimeLabel" style="font-size:12px;color:#666;">时间：—</span>
                </div>
                <div class="playback-time" style="display:flex;flex-direction:column;gap:4px;margin-bottom:8px;">
                    <label class="playback-time-label" style="display:flex;align-items:center;gap:8px;flex:1 1 auto;min-width:0;">
                        <span class="playback-time-text" style="white-space:nowrap;">起始时间：</span>
                        <input type="range" id="playbackTimeSlider" disabled min="0" max="0" step="1000" value="0" style="flex:1 1 auto;min-width:0;max-width:100%;vertical-align:middle;">
                    </label>
                    <span id="playbackTimeCursor" style="font-size:12px;color:#666;align-self:flex-end;">—</span>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let map;
    let currentPolygons = []; // 存储多边形和其标签
    let currentTracks = []; // 存储轨迹折线及相关覆盖物
    let mapLoaded = false;
    let mapLabelHandlers = []; // 存储地图事件处理器
    let labelsEnabled = false; // 标签显示开关（默认关闭）
    let isDrawing = false; // 绘制进行中防止重复点击
    let currentMapType = 'satellite'; // 当前地图类型：'satellite'（卫星图）或'street'（街道图）

    window.onload = function () {
        if (typeof T === 'undefined') {
            alert("天地图API加载失败，请检查网络或密钥！");
            return;
        }
        initMap();
        bindDrawEvent();
        bindMinimizeEvent();
        bindTabs();
        bindBatchGenerator();
        bindMultiSplitter();
        bindLabelsToggle(); // 绑定标签显示开关
        bindTrackEvents();  // 绑定轨迹绘制与清空
        bindPlaybackControls(); // 绑定轨迹回放
        bindMeasureEvents(); // 绑定测量功能
        bindMapTypeEvent(); // 绑定地图类型切换功能
        initColorPickers(); // 初始化颜色选择器
    };

    function initMap() {
        showLoading();
        disableButtons(true);

        try {
            map = new T.Map("mapContainer", {
                zoom: 12,
                center: new T.LngLat(116.40769, 39.90403)
            });

            // 已移除测试标签
            map.enableScrollWheelZoom();

            // 不再添加地图类型控件到地图，改为使用左侧工具条按钮切换
            // const mapTypeCtrl = new T.Control.MapType({
            //     mapTypes: [TMAP_NORMAL_MAP, TMAP_SATELLITE_MAP, TMAP_TERRAIN_MAP],
            //     position: T_ANCHOR_TOP_LEFT
            // });
            // map.addControl(mapTypeCtrl);

            // 加载影像底图（卫星）
            const tk = "648f621977051d0199ff0f965d3fd322";

            // 方案1：使用默认地图类型（作为备选）
            map.setMapType(TMAP_SATELLITE_MAP);
            currentMapType = 'satellite';
            updateMapTypeButton('卫星图');

            // 方案2：手动添加影像图层（底图 + 标注）
            const vecLayer = new T.TileLayer(`https://t0.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=${tk}`);
            const cvaLayer = new T.TileLayer(`https://t0.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=${tk}`);

            // 添加图层并监听加载状态
            vecLayer.addEventListener("load", function () {
                console.log("影像底图加载完成");
            });

            vecLayer.addEventListener("error", function (e) {
                console.error("影像底图加载错误:", e);
                alert("影像底图加载错误，将使用默认地图类型");
            });

            map.addLayer(vecLayer);
            map.addLayer(cvaLayer);

            // 监听地图加载事件
            map.addEventListener("loaded", function () {
                console.log("地图加载完成");
                markMapLoaded();
            });
            map.addEventListener("load", function () {
                console.log("地图load事件触发");
                markMapLoaded();
            });
            map.addEventListener("tilesloaded", function () {
                console.log("地图瓦片加载完成");
                markMapLoaded();
            });
            // 监听地图加载失败事件
            map.addEventListener("error", function (e) {
                console.error("地图加载错误:", e);
                alert("地图加载错误: " + e.message);
                hideLoading();
            });

            // 监听地图移动事件，用于更新标签位置
            const moveHandler = function () {
                updateAllLabelsPosition();
            };
            map.addEventListener("move", moveHandler);
            map.addEventListener("zoom", moveHandler);

            // 存储事件处理器，用于清理
            mapLabelHandlers.push({ event: "move", handler: moveHandler });
            mapLabelHandlers.push({ event: "zoom", handler: moveHandler });

            // 超时容错
            setTimeout(() => {
                if (!mapLoaded) markMapLoaded();
            }, 8000);

        } catch (error) {
            alert("地图初始化失败：" + error.message);
            console.error(error);
            hideLoading();
        }
    }

    function markMapLoaded() {
        if (!mapLoaded) {
            mapLoaded = true;
            hideLoading();
            // 不再禁用按钮，保持按钮始终可用
            // disableButtons(false);
            disableTrackButtons(false);
            // 仅开启速度选择，回放按钮按状态控制
            const speedSel = document.getElementById('playbackSpeedSelect');
            if (speedSel) speedSel.disabled = false;
            updatePlaybackButtonsState('idle');
        }
    }

    function showLoading() {
        const loading = document.getElementById("mapLoading");
        loading.style.display = "flex";
        loading.style.opacity = "1";
    }

    function hideLoading() {
        const loading = document.getElementById("mapLoading");
        loading.style.opacity = "0";
        setTimeout(() => loading.style.display = "none", 300);
    }

    function disableButtons(disabled) {
        // 不再禁用按钮，保持按钮始终可用
        // document.getElementById("drawButton").disabled = disabled;
        // document.getElementById("clearButton").disabled = disabled;
    }

    function disableTrackButtons(disabled) {
        const drawTrackBtn = document.getElementById("drawTrackButton");
        const showTrackPointsBtn = document.getElementById("showTrackPointsButton");
        const clearTrackBtn = document.getElementById("clearTrackButton");
        if (drawTrackBtn) drawTrackBtn.disabled = disabled;
        if (showTrackPointsBtn) showTrackPointsBtn.disabled = disabled;
        if (clearTrackBtn) clearTrackBtn.disabled = disabled;
    }
    // 回放控件的禁用/启用
    function disablePlaybackButtons(disabled) {
        ["playbackStartBtn","playbackPauseBtn","playbackStopBtn","playbackSpeedSelect","playbackTimeSlider"].forEach(id=>{
            const el = document.getElementById(id);
            if (el) el.disabled = disabled;
        });
    }

    // 回放按钮状态管理：空闲/播放/暂停
    function updatePlaybackButtonsState(state){
        try {
            const startBtn = document.getElementById('playbackStartBtn');
            const pauseBtn = document.getElementById('playbackPauseBtn');
            const stopBtn = document.getElementById('playbackStopBtn');
            if (!startBtn || !pauseBtn || !stopBtn) return;
            if (state === 'idle') {
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
                pauseBtn.textContent = '继续';
            } else if (state === 'playing') {
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
                pauseBtn.textContent = '暂停';
            } else if (state === 'paused') {
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
                pauseBtn.textContent = '继续';
            }
        } catch(e) { console.warn('更新按钮状态失败:', e); }
    }

    function bindDrawEvent() {
        document.getElementById("drawButton").addEventListener("click", function () {
            if (isDrawing) { console.log('绘制进行中，忽略重复点击'); return; }
            isDrawing = true;
            showLoading();
            try {
                const wktStr = document.getElementById("wktTextarea").value.trim();
                if (!wktStr) { alert("请输入WKT字符串！"); return; }
                clearOverlays();
                const geojson = parseWkt(wktStr);
    
                const polygonData = [];
                if (geojson.type === "Polygon") {
                    polygonData.push({ index: 1, coordinates: geojson.coordinates });
                } else if (geojson.type === "MultiPolygon") {
                    geojson.coordinates.forEach((polygon, index) => {
                        polygonData.push({ index: index + 1, coordinates: polygon });
                    });
                }
    
                // 重置并绘制
                polygonInfoList = [];
                polygonData.forEach(pd => processPolygon(pd.index, pd.coordinates));
    
                // 视图居中到所有已绘制轮廓
                try { fitViewportToPolygons(); } catch (e) { console.warn('视图居中失败', e); }
    
                // 在视图稳定后再创建/更新标签
                setTimeout(() => {
                    if (labelsEnabled) {
                        try {
                            createAllLabels();
                            updateAllLabelsPosition();
                        } catch (e) {
                            console.warn('创建或更新标签失败:', e);
                        }
                    }
                }, 150);
            } catch (e) {
                alert('绘制失败：' + (e && e.message ? e.message : e));
                console.error('绘制异常:', e);
            } finally {
                hideLoading();
                isDrawing = false;
                // 不再禁用按钮，保持按钮始终可用
                // disableButtons(false);
            }
        });

        document.getElementById("clearButton").addEventListener("click", function () {
            if (isDrawing) { console.log('绘制进行中，暂不清空'); return; }
            clearOverlays();
            console.log("已清空所有轮廓");
        });
    }

    // 存储多边形数据，用于后续标签创建
    let polygonInfoList = [];

    // 处理单个多边形的绘制和面积计算
    function processPolygon(actualPolygonIndex, polygonCoords) {
        console.log('开始处理多边形', actualPolygonIndex);

        // 坐标系选择（绘制始终使用WGS84坐标）
        const coordSys = (document.getElementById('coordSysSelect') && document.getElementById('coordSysSelect').value) || 'wgs84';

        // 统一转换为WGS84用于绘制与面积计算
        function toWgs(point){
            const lng = point[0], lat = point[1];
            if (coordSys === 'wgs84' || coordSys === 'cgcs2000') {
                return [lng, lat];
            } else if (coordSys === 'gcj02') {
                const w = gcj02ToWgs84(lng, lat);
                return [w.lng, w.lat];
            } else if (coordSys === 'bd09') {
                const gcj = bd09ToGcj02(lng, lat);
                const w = gcj02ToWgs84(gcj.lng, gcj.lat);
                return [w.lng, w.lat];
            }
            return [lng, lat];
        }
        const coordsWGS84 = polygonCoords.map(ring => ring.map(toWgs));
        let outerRingWGS = coordsWGS84[0] || [];

        // 生成用于绘制的坐标（直接使用WGS84坐标）
        const rings = coordsWGS84.map(ring => ring.map(([lng, lat]) => new T.LngLat(lng, lat)));


         // 创建半透明填充的多边形（无边框）
          const polygon = new T.Polygon(rings, {
              color: currentOutlineColor,
              weight: 1,
              opacity: 1,
              fillColor: currentFillColor,
              fillOpacity: currentFillOpacity
          });
 
          // 使用WGS84坐标计算面积（更准确的面积计算）
         let areaSqm;
         let areaMu;



         try {
             // 检查Turf.js是否可用
             if (typeof turf !== 'undefined' && turf.area) {
                 // 使用Turf.js计算多边形面积
                // 构造GeoJSON格式的多边形
                const geoJsonPolygon = {
                    type: "Polygon",
                    coordinates: coordsWGS84
                };


                 // 使用Turf.js计算面积（平方米）
                 areaSqm = turf.area(geoJsonPolygon);
                 areaMu = (areaSqm / 666.6667).toFixed(4); // 转换为亩
                 console.log(`多边形${actualPolygonIndex}面积计算结果(Turf.js): ${areaSqm}平方米 = ${areaMu}亩`);
             } else {
                 // 如果Turf.js不可用，回退到之前的计算方法
                 console.warn('Turf.js不可用，使用备用计算方法');
                 // 计算带孔洞的多边形面积
                 areaSqm = 0;
                 // 计算外环面积
                 outerRingWGS = coordsWGS84[0] || [];
                 areaSqm += calculatePolygonArea(outerRingWGS);

                 // 减去内环（孔洞）面积
                 for (let i = 1; i < coordsWGS84.length; i++) {
                     const innerRingArea = calculatePolygonArea(coordsWGS84[i]);
                     areaSqm -= innerRingArea;
                 }

                  areaMu = (areaSqm / 666.6667).toFixed(4); // 使用更精确的转换系数
                  console.log(`多边形${actualPolygonIndex}面积计算结果(备用): ${areaSqm}平方米 = ${areaMu}亩`);
              }
          } catch (error) {
              console.error(`面积计算失败:`, error);
              areaSqm = 0;
              areaMu = '0.0000';
          }

          // 计算多边形的中心点和底部中心点（WGS84）
          const centerPoint = calculatePolygonCenter(outerRingWGS);
          const bottomCenterPoint = calculatePolygonBottomCenter(outerRingWGS);

          // 添加多边形到地图
          if (map) {
              map.addOverLay(polygon);
              console.log(`多边形${actualPolygonIndex}已添加到地图`);
          } else {
              console.error('地图对象不存在');
          }

          // 存储多边形信息，用于后续标签创建
          polygonInfoList.push({
              index: actualPolygonIndex,
              polygon: polygon,
              area: areaMu,
              bottomCenter: { lng: bottomCenterPoint.lng, lat: bottomCenterPoint.lat },
              ringPoints: rings
          });
      }

    // 视图居中：根据已绘制的GCJ-02点
    function fitViewportToPolygons() {
        const points = [];
        try {
            if (!map || !map.setViewport) return;
            polygonInfoList.forEach(info => {
                if (!info || !info.ringPoints) return;
                info.ringPoints.forEach(ring => {
                    ring.forEach(ll => points.push(ll));
                });
            });
            if (!points.length) return;
            map.setViewport(points);
        } catch (e) {
            try {
                const lngs = points.map(p => p.lng);
                const lats = points.map(p => p.lat);
                const center = new T.LngLat(
                    (Math.min(...lngs) + Math.max(...lngs)) / 2,
                    (Math.min(...lats) + Math.max(...lats)) / 2
                );
                if (map && map.panTo) map.panTo(center);
            } catch (e2) {
                console.warn('视图居中失败:', e2);
            }
        }
    }

    // 统一创建所有多边形的标签
    function createAllLabels() {
        const mapContainer = document.getElementById('mapContainer');
        if (!mapContainer || !map) return;

        polygonInfoList.forEach(info => {
            if (!info) return;
            // 防止重复创建
            if (info.labelRef) return;
            // 创建标签元素
            const labelDiv = document.createElement('div');
            labelDiv.className = 'area-label';
            labelDiv.innerHTML = `多边形${info.index}：${info.area}亩`;

            // 添加到地图容器并根据屏幕边界定位到轮廓下方
            mapContainer.appendChild(labelDiv);
            positionLabelForPolygon(labelDiv, info);

            // 记录引用，避免重复创建
            info.labelRef = labelDiv;

            // 存储到 currentPolygons 以复用现有定位/清理逻辑
            const labelObj = {
                domElement: labelDiv,
                isDomLabel: true,
                polygonInfo: info
            };
            currentPolygons.push({ polygon: info.polygon, label: labelObj });
        });

        // 不清空 polygonInfoList，便于开关随时创建/隐藏标签
    }

    // 根据多边形屏幕边界定位标签，保证始终在轮廓下方
    function positionLabelForPolygon(labelDiv, info) {
        if (!map || !info || !info.ringPoints) return;
        const points = [];
        info.ringPoints.forEach(ring => {
            ring.forEach(ll => {
                const p = map.lngLatToContainerPoint(ll);
                points.push(p);
            });
        });
        if (!points.length) return;
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const maxY = Math.max(...points.map(p => p.y));
        const container = document.getElementById('mapContainer');
        const labelWidth = labelDiv.offsetWidth;
        const labelHeight = labelDiv.offsetHeight;
        const targetLeft = Math.round((minX + maxX) / 2 - labelWidth / 2);
        const targetTop = Math.round(maxY + 6);
        const clampedLeft = Math.max(0, Math.min(targetLeft, container.clientWidth - labelWidth));
        const clampedTop = Math.max(0, Math.min(targetTop, container.clientHeight - labelHeight));
        labelDiv.style.left = clampedLeft + 'px';
        labelDiv.style.top = clampedTop + 'px';
    }

    // 更新所有标签位置（地图move/zoom时调用）
    function updateAllLabelsPosition() {
        try {
            if (!map) return;
            const container = document.getElementById('mapContainer');
            if (!container) return;
            currentPolygons.forEach(item => {
                if (!item || !item.label) return;
                const labelObj = item.label;
                if (labelObj.isDomLabel && labelObj.domElement && labelObj.polygonInfo) {
                    // 确保标签在容器中
                    if (!labelObj.domElement.parentNode) {
                        container.appendChild(labelObj.domElement);
                    }
                    positionLabelForPolygon(labelObj.domElement, labelObj.polygonInfo);
                }
            });
        } catch (e) {
            console.warn('更新标签位置时出错:', e);
        }
    }
    // 确保在全局可用（处理第三方库事件回调作用域差异）
    window.updateAllLabelsPosition = updateAllLabelsPosition;

    // 绑定“显示亩数标签”开关（默认隐藏）
    function bindLabelsToggle() {
        const cb = document.getElementById('toggleLabelsCheckbox');
        const container = document.getElementById('mapContainer');
        if (!cb || !container) return;
        // 默认隐藏标签
        container.classList.add('labels-hidden');
        cb.addEventListener('change', () => {
            labelsEnabled = cb.checked;
            if (labelsEnabled) {
                container.classList.remove('labels-hidden');
                const hasAnyLabel = currentPolygons.some(item => item && item.label && item.label.domElement);
                if (!hasAnyLabel) {
                    try { createAllLabels(); } catch (e) { console.warn('创建标签失败:', e); }
                }
                updateAllLabelsPosition();
            } else {
                container.classList.add('labels-hidden');
            }
        });
    }

    /**
     * 计算多边形中心点（比底部中心更适合显示标签）
     */
    function calculatePolygonCenter(outerRing) {
        let sumLng = 0, sumLat = 0;
        const len = outerRing.length;

        for (let i = 0; i < len; i++) {
            sumLng += outerRing[i][0];
            sumLat += outerRing[i][1];
        }

        return {
            lng: sumLng / len,
            lat: sumLat / len
        };
    }

    /**
     * 计算多边形面积（球面多边形面积计算）
     * 使用更准确的球面坐标面积计算方法，确保面积与视觉大小一致
     */
    function calculatePolygonArea(coordinates) {
        // 地球半径（米）- 使用更精确的值
        const R = 6371000.8;
        const n = coordinates.length;

        // 将所有坐标转换为弧度
        const coordsRad = coordinates.map(point => [
            point[0] * Math.PI / 180,
            point[1] * Math.PI / 180
        ]);

        let areaRad = 0;

        // 使用更准确的球面多边形面积公式（Girard定理）
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            const lon1 = coordsRad[i][0];
            const lat1 = coordsRad[i][1];
            const lon2 = coordsRad[j][0];
            const lat2 = coordsRad[j][1];

            // 计算球面多边形面积增量
            const dlon = lon2 - lon1;
            const sinLat1 = Math.sin(lat1);
            const sinLat2 = Math.sin(lat2);
            const cosLat1 = Math.cos(lat1);
            const cosLat2 = Math.cos(lat2);

            // 使用更精确的公式
            areaRad += dlon * (sinLat1 * cosLat2 * Math.cos(dlon / 2) + sinLat2 * cosLat1);
        }

        // 计算总面积（平方米）
        const areaSqm = Math.abs(areaRad) * R * R * 0.5;

        return areaSqm;
    }

    /**
     * 清空所有多边形和标签（同时处理 polygonInfoList 与 currentPolygons）
     */
    function clearOverlays() {
        try {
            // 先移除 polygonInfoList 中记录的多边形与其DOM标签
            polygonInfoList.forEach(info => {
                if (info && info.polygon && map && map.removeOverLay) {
                    try { map.removeOverLay(info.polygon); } catch (e) { console.warn('移除多边形失败:', e); }
                }
                if (info && info.labelRef && info.labelRef.parentNode) {
                    try { info.labelRef.parentNode.removeChild(info.labelRef); } catch (e) { console.warn('移除DOM标签失败:', e); }
                    info.labelRef = null;
                }
            });

            // 再处理 currentPolygons（兼容旧路径与标签对象）
            currentPolygons.forEach(item => {
                if (item.polygon && map && map.removeOverLay) {
                    try { map.removeOverLay(item.polygon); } catch (e) { console.warn('移除多边形失败:', e); }
                }
                if (item.label) {
                    if (item.label.domElement && item.label.domElement.parentNode) {
                        try { item.label.domElement.parentNode.removeChild(item.label.domElement); } catch (e) { console.warn('移除DOM标签失败:', e); }
                    } else if (map && map.removeOverLay && !item.label.isDomLabel) {
                        try { map.removeOverLay(item.label); } catch (e) { console.warn('移除地图覆盖物标签失败:', e); }
                    }
                }
            });

            // 清空记录数组
            currentPolygons = [];
            polygonInfoList = [];

            console.log('已清空所有多边形和标签（保留事件监听器）');
        } catch (error) {
            console.error('清空覆盖物时出错:', error);
        }
    }

    // 其他辅助函数（保持不变）
    function bindMinimizeEvent() {
        const container = document.querySelector(".wkt-input-container");
        const btn = document.getElementById("minimizeBtn");
        const minIcon = btn?.querySelector(".min-icon");
        const restoreIcon = btn?.querySelector(".restore-icon");

        btn?.addEventListener("click", () => {
            const minimized = container.classList.toggle("minimized");
            if (minIcon && restoreIcon) {
                if (minimized) {
                    minIcon.style.display = "none";
                    restoreIcon.style.display = "";
                } else {
                    minIcon.style.display = "";
                    restoreIcon.style.display = "none";
                }
            }
        });
    }

    // 在脚本内部补充：页签切换（3个页签）
     function bindTabs() {
         const tabs = [
             { btn: document.getElementById('tabDrawBtn'), pane: document.getElementById('tabDraw'), key: 'draw' },
             { btn: document.getElementById('tabTrackBtn'), pane: document.getElementById('tabTrack'), key: 'track' },
             { btn: document.getElementById('tabSplitBtn'), pane: document.getElementById('tabSplit'), key: 'split' },
             { btn: document.getElementById('tabBatchBtn'), pane: document.getElementById('tabBatch'), key: 'batch' },
         ];
         if (tabs.some(t => !t.btn || !t.pane)) return;
         function activate(key) {
             tabs.forEach(t => {
                 const active = t.key === key;
                 t.btn.classList.toggle('active', active);
                 t.pane.classList.toggle('active', active);
             });
         }
         tabs.forEach(t => t.btn.addEventListener('click', () => activate(t.key)));
         activate('draw');
     }
    function updateParserStatus() {
        const el = document.getElementById('parserStatus');
        if (!el) return;
        const ok = (typeof Terraformer !== 'undefined' && Terraformer.WKT && typeof Terraformer.WKT.parse === 'function');
        if (ok) {
            el.textContent = 'Terraformer WKT Parser';
            el.style.color = '#2f8f2f';
        } else {
            el.textContent = '本地回退解析（仅支持POLYGON/MULTIPOLYGON）';
            el.style.color = '#c77d1e';
        }
    }
     function parseWkt(wkt) {
         wkt = wkt.trim();
         // 优先使用成熟库（Terraformer WKT Parser）
         if (typeof Terraformer !== 'undefined' && Terraformer.WKT && Terraformer.WKT.parse) {
             try {
                 return Terraformer.WKT.parse(wkt);
             } catch (e) {
                 console.warn('Terraformer解析失败，尝试本地回退解析:', e);
             }
         } else {
             // 不再提示“未加载”，由状态栏展示回退信息
         }
         // 回退解析：仅支持 POLYGON / MULTIPOLYGON
         const typeMatch = wkt.match(/^\s*(POLYGON|MULTIPOLYGON)\s*\(/i);
         if (!typeMatch) throw new Error('仅支持POLYGON/MULTIPOLYGON');
         const type = typeMatch[1].toUpperCase();
         const inner = wkt.substring(wkt.indexOf('('));
         if (type === 'POLYGON') {
             const coords = parsePolygonCoords(inner.replace(/^\(/, '').replace(/\)$/, ''));
             return { type: 'Polygon', coordinates: coords };
         } else {
             const trimmed = inner.replace(/^\(\(/, '').replace(/\)\)$/, '');
             const coords = parseMultiPolygonCoords(trimmed);
             return { type: 'MultiPolygon', coordinates: coords };
         }
     }

     function bindMultiSplitter() {
         const input = document.getElementById('multiInput');
         const output = document.getElementById('polyOutput');
         const splitBtn = document.getElementById('splitMultiBtn');
         const copyBtn = document.getElementById('copyPolysBtn');
         if (!input || !output || !splitBtn || !copyBtn) return;

         // 本地WKT序列化辅助
         function ringToText(ring) {
             if (!ring || !ring.length) return '()';
             const first = ring[0];
             const last = ring[ring.length - 1];
             const closed = (first[0] === last[0] && first[1] === last[1]) ? ring : ring.concat([[first[0], first[1]]]);
             return '(' + closed.map(pt => pt[0] + ' ' + pt[1]).join(', ') + ')';
         }
         function toWktPolygonCoords(coords) {
             return 'POLYGON(' + coords.map(ringToText).join(', ') + ')';
         }
         function toWktMulti(coords) {
             return 'MULTIPOLYGON(' + coords.map(poly => '(' + poly.map(ringToText).join(', ') + ')').join(', ') + ')';
         }

         function polygonsFromMulti(text) {
             const geo = parseWkt(text.trim());
             if (geo.type !== 'MultiPolygon') throw new Error('请输入有效的 MULTIPOLYGON WKT');
             const polys = geo.coordinates.map(rings => toWktPolygonCoords(rings));
             return polys;
         }
         splitBtn.addEventListener('click', () => {
             try {
                 const list = polygonsFromMulti(input.value.trim());
                 output.value = list.join('\n');
             } catch (e) {
                 alert('分割失败：' + e.message);
             }
         });
         copyBtn.addEventListener('click', async () => {
             const val = output.value.trim();
             if (!val) { alert('没有可复制的结果'); return; }
             try { await navigator.clipboard.writeText(val); alert('已复制到剪贴板'); } catch (e) { console.warn('复制失败', e); }
         });
     }

     function bindBatchGenerator() {
         const batchInput = document.getElementById('batchInput');
         const output = document.getElementById('multiOutput');
         const genBtn = document.getElementById('generateMultiBtn');
         const copyBtn = document.getElementById('copyMultiBtn');

         // 本地WKT序列化辅助（与分割器保持一致）
         function ringToText(ring) {
             if (!ring || !ring.length) return '()';
             const first = ring[0];
             const last = ring[ring.length - 1];
             const closed = (first[0] === last[0] && first[1] === last[1]) ? ring : ring.concat([[first[0], first[1]]]);
             return '(' + closed.map(pt => pt[0] + ' ' + pt[1]).join(', ') + ')';
         }
         function toWktMulti(coords) {
             return 'MULTIPOLYGON(' + coords.map(poly => '(' + poly.map(ringToText).join(', ') + ')').join(', ') + ')';
         }

         genBtn.addEventListener('click', () => {
             try {
                 const lines = batchInput.value.trim().split(/\n|;/).map(s => s.trim()).filter(Boolean);
                 if (lines.length === 0) throw new Error('请按每行或分号输入至少一个POLYGON');
                 const polygons = lines.map((line, idx) => {
                     const g = parseWkt(line);
                     if (g.type !== 'Polygon') throw new Error(`第${idx + 1}行不是有效的POLYGON WKT`);
                     return g;
                 });
                 const multiGeo = { type: 'MultiPolygon', coordinates: polygons.map(p => p.coordinates) };
                 output.value = toWktMulti(multiGeo.coordinates);
             } catch (e) {
                 alert('生成失败：' + e.message);
             }
         });

         copyBtn.addEventListener('click', async () => {
             const val = output.value.trim();
             if (!val) { alert('没有可复制的结果'); return; }
             try { await navigator.clipboard.writeText(val); alert('已复制到剪贴板'); } catch (e) { console.warn('复制失败', e); }
         });

     }

     function setExampleWkt() {
         const exampleWkt = "MULTIPOLYGON(" +
             "(" +
             "(116.35 39.93, 116.39 39.93, 116.39 39.90, 116.35 39.90, 116.35 39.93)," + // 外环
             "(116.36 39.92, 116.38 39.92, 116.38 39.91, 116.36 39.91, 116.36 39.92)" +  // 内环
             ")," +
             "(" +
             "(116.40 39.95, 116.43 39.97, 116.46 39.96, 116.49 39.98, 116.52 39.95, 116.55 39.93, 116.58 39.94, 116.61 39.92, 116.64 39.95, 116.40 39.95)" +
             ")" +
             ")";
         document.getElementById("wktTextarea").value = exampleWkt;
     }

     function parsePolygonCoords(coordStr) {
         const ringStrs = coordStr.split(/\)\s*,\s*\(/).map(s => s.replace(/[()]/g, '').trim());
         const rings = [];
         ringStrs.forEach(ringStr => {
             const pts = ringStr.split(/,\s*/).map(pointStr => {
                 const [lng, lat] = pointStr.split(/\s+/).map(Number);
                 if (isNaN(lng) || isNaN(lat)) throw new Error("坐标格式错误：" + pointStr);
                 return [lng, lat];
             });
             // 自动拆分：如果一个ring中包含多次回到起点（闭合），则拆分为多个环
             // 兼容用户将外环与内环错误地写在同一对括号中的情况
             let start = 0;
             while (start < pts.length) {
                 const startPt = pts[start];
                 let closeIdx = -1;
                 for (let i = start + 1; i < pts.length; i++) {
                     if (pts[i][0] === startPt[0] && pts[i][1] === startPt[1]) {
                         closeIdx = i;
                         break;
                     }
                 }
                 if (closeIdx === -1) {
                     // 未找到闭合：将剩余点视为一个环，并强制闭合
                     const ring = pts.slice(start);
                     if (ring.length && (ring[0][0] !== ring[ring.length - 1][0] || ring[0][1] !== ring[ring.length - 1][1])) {
                         ring.push([ring[0][0], ring[0][1]]);
                     }
                     rings.push(ring);
                     break;
                 } else {
                     const ring = pts.slice(start, closeIdx + 1);
                     rings.push(ring);
                     start = closeIdx + 1;
                 }
             }
         });
         return rings;
     }

     function parseMultiPolygonCoords(coordStr) {
         const polygonStrs = coordStr.split(/\)\s*\)\s*,\s*\(\s*\(/).map(s => s.replace(/[()]/g, '').trim());
         return polygonStrs.map(polygonStr => parsePolygonCoords(polygonStr));
     }

     function wgs84ToGcj02(lng, lat) {
         const x_PI = 3.14159265358979324 * 3000.0 / 180.0;
         const PI = 3.1415926535897932384626;
         const a = 6378245.0;
         const ee = 0.00669342162296594323;

         if (outOfChina(lng, lat)) return { lng, lat };

         let dlat = transformLat(lng - 105.0, lat - 35.0);
         let dlng = transformLng(lng - 105.0, lat - 35.0);
         const radlat = lat / 180.0 * PI;
         let magic = Math.sin(radlat);
         magic = 1 - ee * magic * magic;
         const sqrtmagic = Math.sqrt(magic);
         dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI);
         dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI);

         return { lng: lng + dlng, lat: lat + dlat };

         function outOfChina(lng, lat) {
             return (lng < 72.004 || lng > 137.8347) || (lat < 0.8293 || lat > 55.8271);
         }

         function transformLat(x, y) {
             let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
             ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
             ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0;
             ret += (160.0 * Math.sin(y / 12.0 * PI) + 320 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0;
             return ret;
         }

         function transformLng(x, y) {
             let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
             ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
             ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0;
             ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0;
             return ret;
         }
     }

     function gcj02ToWgs84(lng, lat) {
         const g = wgs84ToGcj02(lng, lat);
         return { lng: lng * 2 - g.lng, lat: lat * 2 - g.lat };
     }

     function bd09ToGcj02(bdLng, bdLat) {
         const x_PI = 3.14159265358979324 * 3000.0 / 180.0;
         const x = bdLng - 0.0065;
         const y = bdLat - 0.006;
         const z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_PI);
         const theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_PI);
         const ggLng = z * Math.cos(theta);
         const ggLat = z * Math.sin(theta);
         return { lng: ggLng, lat: ggLat };
     }

     function calculatePolygonBottomCenter(outerRing) {
         let minLat = Infinity;
         let bottomPoints = [];
         outerRing.forEach(point => {
             const lat = point[1];
             if (lat < minLat) {
                 minLat = lat;
                 bottomPoints = [point];
             } else if (lat === minLat) {
                 bottomPoints.push(point);
             }
         });

         const sumLng = bottomPoints.reduce((sum, point) => sum + point[0], 0);
         const centerLng = sumLng / bottomPoints.length;

         return { lng: centerLng, lat: minLat };
     }

     function fitBounds(geojson) {
         try {
             const allPoints = [];
             function collectPoints(coords) {
                 if (typeof coords[0] === 'number') {
                     allPoints.push(coords);
                 } else {
                     coords.forEach(coord => collectPoints(coord));
                 }
             }
             collectPoints(geojson.coordinates);

             if (allPoints.length === 0) return;

             const lats = allPoints.map(p => p[1]);
             const lngs = allPoints.map(p => p[0]);
             const minLng = Math.min(...lngs);
             const maxLng = Math.max(...lngs);
             const minLat = Math.min(...lats);
             const maxLat = Math.max(...lats);

             const sw = wgs84ToGcj02(minLng, minLat);
             const ne = wgs84ToGcj02(maxLng, maxLat);

             // 修复setViewport方法的使用，确保参数格式正确
             if (map && map.setViewport) {
                 map.setViewport([
                     new T.LngLat(sw.lng, sw.lat),
                     new T.LngLat(ne.lng, ne.lat)
                 ], { padding: [50, 50] });
             } else {
                 console.warn('地图对象或setViewport方法不可用');
             }
         } catch (error) {
             console.error('调整视图范围时出错:', error);
         }
     }
// 轨迹绘制与解析
    function bindTrackEvents() {
        const drawBtn = document.getElementById('drawTrackButton');
        const showPointsBtn = document.getElementById('showTrackPointsButton');
        const clearBtn = document.getElementById('clearTrackButton');
        const ta = document.getElementById('trackTextarea');
        if (!drawBtn || !showPointsBtn || !clearBtn || !ta) return;

        drawBtn.addEventListener('click', function(){
            try {
                const text = ta.value.trim();
                if (!text) { alert('请粘贴轨迹文本（时间戳,经度,纬度）'); return; }
                const points = parseTrackText(text);
                if (points.length < 2) { alert('有效轨迹点不足，至少需要两点'); return; }
                drawTrackFromPoints(points);
                fitViewportToTrack(points);
            } catch (e) {
                alert('绘制轨迹失败：' + (e && e.message ? e.message : e));
                console.error('绘制轨迹异常:', e);
            }
        });

        showPointsBtn.addEventListener('click', function(){
            try {
                const text = ta.value.trim();
                if (!text) { alert('请粘贴轨迹文本（时间戳,经度,纬度）'); return; }
                const points = parseTrackText(text);
                if (points.length === 0) { alert('未找到有效轨迹点'); return; }
                showTrackPoints(points);
                fitViewportToTrack(points);
            } catch (e) {
                alert('显示轨迹点失败：' + (e && e.message ? e.message : e));
                console.error('显示轨迹点异常:', e);
            }
        });

        clearBtn.addEventListener('click', function(){
            clearTrackOverlays();
            console.log('已清空轨迹');
        });
    }

    function showTrackPoints(points) {
        // 先移除旧轨迹（不影响轮廓）
        clearTrackOverlays(false);
        
        if (!map || !points || points.length === 0) {
            console.log('无轨迹点可显示');
            return;
        }
        
        console.log(`准备显示${points.length}个轨迹点`);
        
        // 使用批量处理和更小的图标来提高性能
        // 创建一个更小的自定义颜色点SVG图标
        const smallColoredDotIcon = new T.Icon({
            iconUrl: `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"><circle cx="0.5" cy="0.5" r="0.3" fill="%23${currentTrackPointColor.substring(1)}"/></svg>`,
            iconSize: new T.Point(1, 1),
            iconAnchor: new T.Point(0.5, 0.5)
        });
        
        // 优化批量添加点的速度
        const batchSize = 2000; // 增加每批处理的点数
        const concurrentBatches = 4; // 并发批次数量
        
        // 预创建点击事件处理函数，避免重复创建
        function createClickHandler(point, index) {
            return function() {
                const infoWindow = new T.InfoWindow({
                    content: `点${index + 1}<br/>经度: ${point.lng.toFixed(6)}<br/>纬度: ${point.lat.toFixed(6)}`,
                    offset: new T.Point(0, -20)
                });
                infoWindow.open(map, point);
            };
        }
        
        // 使用setTimeout实现更高效的批量添加，避免阻塞UI
        let currentIndex = 0;
        
        function addBatch() {
            if (currentIndex >= points.length) {
                console.log(`已显示${points.length}个轨迹点`);
                return;
            }
            
            // 添加当前批次的点
            const endIndex = Math.min(currentIndex + batchSize, points.length);
            const markersToAdd = [];
            
            // 先创建所有标记
            for (let i = currentIndex; i < endIndex; i++) {
                const point = points[i];
                const index = i;
                
                const marker = new T.Marker(point, {
                    icon: smallColoredDotIcon
                });
                
                // 添加点击事件
                marker.addEventListener('click', createClickHandler(point, index));
                
                markersToAdd.push(marker);
            }
            
            // 批量添加到地图和数组
            markersToAdd.forEach(marker => {
                map.addOverLay(marker);
                currentTracks.push(marker);
            });
            
            currentIndex = endIndex;
            
            // 使用setTimeout而不是requestAnimationFrame，减少对渲染周期的依赖
            // 设置为0，将任务放入微任务队列，但允许UI有短暂的呼吸空间
            setTimeout(addBatch, 0);
        }
        
        // 启动批量添加
        addBatch();
    }
    
    // 恢复原始的clearTrackOverlays函数
    function clearTrackOverlays(resetArray = true){        
        try {
            currentTracks.forEach(pl => {
                if (pl && map && map.removeOverLay) {
                    try { map.removeOverLay(pl); } catch (e) { console.warn('移除轨迹失败:', e); }
                }
            });
            if (resetArray) currentTracks = [];
        } catch (e) {
            console.warn('清空轨迹时出错:', e);
        }
    }

    function parseTrackText(text){
        // 选择输入坐标系（优先使用轨迹页签专属选择器，若未设置则回退到绘制页签选择器）
        const coordSysEl = document.getElementById('trackCoordSysSelect') || document.getElementById('coordSysSelect');
        const coordSys = (coordSysEl && coordSysEl.value) || 'wgs84';
        const isHash = text.indexOf('#') !== -1;
        const items = isHash ? text.split('#') : text.split(/\r?\n/);
        const pts = [];
        for (let i=0;i<items.length;i++){
            const raw = items[i];
            if (!raw) continue;
            const line = raw.trim();
            if (!line) continue;
            const parts = line.split(',');
            if (parts.length < 3) continue;
            let lng = parseFloat((parts[isHash ? 0 : 1] || '').trim());
            let lat = parseFloat((parts[isHash ? 1 : 2] || '').trim());
            // 初步过滤：数值合法性与正常范围
            if (!isFinite(lng) || !isFinite(lat)) continue;
            if (lng === 0 || lat === 0) continue; // 丢弃0.0异常点
            if (lng < -180 || lng > 180 || lat < -90 || lat > 90) continue; // 超出经纬度范围丢弃

            // 将输入坐标转换为WGS84
            let w;
            if (coordSys === 'wgs84' || coordSys === 'cgcs2000') {
                w = { lng, lat };
            } else if (coordSys === 'gcj02') {
                w = gcj02ToWgs84(lng, lat);
            } else if (coordSys === 'bd09') {
                const g = bd09ToGcj02(lng, lat);
                w = gcj02ToWgs84(g.lng, g.lat);
            } else {
                w = { lng, lat };
            }
            // 转换结果兜底检查
            if (!isFinite(w.lng) || !isFinite(w.lat)) continue;
            if (w.lng < -180 || w.lng > 180 || w.lat < -90 || w.lat > 90) continue;

            // 使用WGS84坐标绘制到地图
            pts.push(new T.LngLat(w.lng, w.lat));
        }
        return pts;
    }

    function drawTrackFromPoints(points){
        // 先移除旧轨迹（不影响轮廓）
        clearTrackOverlays(false);
        const polyline = new T.Polyline(points, {
            color: currentTrackLineColor,
            weight: 1,
            opacity: 0.9
        });
        if (map) {
            map.addOverLay(polyline);
        }
        currentTracks.push(polyline);
    }

    function clearTrackOverlays(resetArray = true){
        try {
            currentTracks.forEach(pl => {
                if (pl && map && map.removeOverLay) {
                    try { map.removeOverLay(pl); } catch (e) { console.warn('移除轨迹失败:', e); }
                }
            });
            if (resetArray) currentTracks = [];
        } catch (e) {
            console.warn('清空轨迹时出错:', e);
        }
    }


    function fitViewportToTrack(points){
        try {
            if (!map || !map.setViewport || !points || !points.length) return;
            map.setViewport(points);
        } catch (e) {
            console.warn('轨迹视图居中失败:', e);
        }
    }

    // ========= 轨迹回放功能 =========
    let playbackState = { points: [], idx: 0, speed: 1, timer: null, running: false, marker: null, line: null, path: [] };

    function bindPlaybackControls(){
        const startBtn = document.getElementById('playbackStartBtn');
        const pauseBtn = document.getElementById('playbackPauseBtn');
        const stopBtn = document.getElementById('playbackStopBtn');
        const speedSel = document.getElementById('playbackSpeedSelect');
        const timeSlider = document.getElementById('playbackTimeSlider');
        const timeCursor = document.getElementById('playbackTimeCursor');
        const ta = document.getElementById('trackTextarea');
        if (!startBtn || !pauseBtn || !stopBtn || !speedSel) return;

        // 初始按钮状态
        updatePlaybackButtonsState('idle');

        startBtn.addEventListener('click', function(){
            try {
                const text = (ta && ta.value || '').trim();
                if (!text) { alert('请粘贴轨迹文本（时间戳,经度,纬度）'); return; }
                const pts = parseTrackTextWithTime(text);
                if (pts.length < 2) { alert('有效轨迹点不足，至少需要两点'); return; }
                startPlayback(pts);
                // 状态在startPlayback中已设置为playing
            } catch (e) {
                alert('开始回放失败：' + (e && e.message ? e.message : e));
                console.error('开始回放异常:', e);
            }
        });

        pauseBtn.addEventListener('click', function(){
            if (!playbackState.running) {
                // 继续
                playbackState.running = true;
                scheduleNext();
                updatePlaybackButtonsState('playing');
            } else {
                // 暂停
                if (playbackState.timer) { clearTimeout(playbackState.timer); playbackState.timer = null; }
                playbackState.running = false;
                updatePlaybackButtonsState('paused');
            }
        });

        stopBtn.addEventListener('click', function(){ 
            stopPlayback(); 
            updatePlaybackButtonsState('idle');
        });

        speedSel.addEventListener('change', function(){
            const v = parseFloat(speedSel.value);
            playbackState.speed = (isFinite(v) && v > 0) ? v : 1;
        });

        if (timeSlider) {
            timeSlider.addEventListener('input', function(){
                const ms = parseInt(timeSlider.value, 10);
                const txt = formatTimeForLabel(ms);
                if (timeCursor) timeCursor.textContent = txt;
            });
            timeSlider.addEventListener('change', function(){
                jumpToSliderTime();
            });
        }
    }

    function parseTrackTextWithTime(text){
        const coordSysEl = document.getElementById('trackCoordSysSelect') || document.getElementById('coordSysSelect');
        const coordSys = (coordSysEl && coordSysEl.value) || 'wgs84';
        const isHash = text.indexOf('#') !== -1;
        const items = isHash ? text.split('#') : text.split(/\r?\n/);
        const out = [];
        for (let i=0;i<items.length;i++){
            const raw = items[i];
            if (!raw) continue;
            const line = raw.trim();
            if (!line) continue;
            const parts = line.split(',');
            if (parts.length < 3) continue;
            const tsRaw = (parts[isHash ? 2 : 0] || '').trim();
            const ts = (tsRaw || '').replace(/\D/g,'');
            let lng = parseFloat((parts[isHash ? 0 : 1] || '').trim());
            let lat = parseFloat((parts[isHash ? 1 : 2] || '').trim());
            if (!isFinite(lng) || !isFinite(lat)) continue;
            if (lng === 0 || lat === 0) continue;
            if (lng < -180 || lng > 180 || lat < -90 || lat > 90) continue;
            const t = parseTimestamp(ts);
            if (!t) continue;
            let w;
            if (coordSys === 'wgs84' || coordSys === 'cgcs2000') {
                w = { lng, lat };
            } else if (coordSys === 'gcj02') {
                w = gcj02ToWgs84(lng, lat);
            } else if (coordSys === 'bd09') {
                const g = bd09ToGcj02(lng, lat);
                w = gcj02ToWgs84(g.lng, g.lat);
            } else { w = { lng, lat }; }
            if (!isFinite(w.lng) || !isFinite(w.lat)) continue;
            if (w.lng < -180 || w.lng > 180 || w.lat < -90 || w.lat > 90) continue;
            out.push({ ll: new T.LngLat(w.lng, w.lat), time: t, ts });
        }
        out.sort((a,b)=>a.time - b.time);
        return out;
    }

    function parseTimestamp(ts){
        const tstr = (ts || '').replace(/\D/g,'');
        const m = tstr && tstr.match(/^\d{14}$/);
        if (!m) return null;
        const y = parseInt(tstr.slice(0,4),10);
        const M = parseInt(tstr.slice(4,6),10) - 1;
        const d = parseInt(tstr.slice(6,8),10);
        const h = parseInt(tstr.slice(8,10),10);
        const m2 = parseInt(tstr.slice(10,12),10);
        const s = parseInt(tstr.slice(12,14),10);
        const dt = new Date(y,M,d,h,m2,s);
        return isNaN(dt.getTime()) ? null : dt;
    }

    function startPlayback(points){
        console.log('[Playback] startPlayback: 点数=', points && points.length);
        stopPlayback();
        playbackState.points = points;
        playbackState.idx = 0;
        playbackState.speed = playbackState.speed || 1;
        playbackState.running = true;
        // 配置时间滑动条，并尊重现有滑块位置作为起始
        configureTimeSlider(points);
        // 启用滑块
        const slider = document.getElementById('playbackTimeSlider');
        if (slider) slider.disabled = false;
        let initIdx = 0;
        if (slider && slider.min && slider.max) {
            const ms = parseInt(slider.value, 10);
            if (isFinite(ms)) initIdx = findIndexByTime(points, ms);
        }
        playbackState.idx = initIdx;
        const first = points[initIdx];
        console.log('[Playback] 首点:', first && first.ts, first && first.ll, 'initIdx=', initIdx);
        playbackState.path = points.slice(0, initIdx+1).map(p=>p.ll);
        playbackState.line = new T.Polyline(playbackState.path, { color: currentTrackLineColor, weight: 1, opacity: 0.9 });
        if (map) {
            map.addOverLay(playbackState.line);
        }
        currentTracks.push(playbackState.line);
        // 创建并定位DOM标记以保证可见移动
        ensurePlaybackDom(first.ll);
        updatePlaybackDom(first.ll);
        updatePlaybackTimeLabel(first.ts);
        try { fitViewportToTrack(points.map(p=>p.ll)); } catch(e){}
        // 更新按钮状态
        updatePlaybackButtonsState('playing');
        scheduleNext();
    }

    function scheduleNext(){
        if (!playbackState.running) return;
        if (!playbackState.points || playbackState.idx >= playbackState.points.length - 1) {
            playbackState.running = false;
            console.log('[Playback] 回放结束：idx=', playbackState.idx, '点数=', playbackState.points ? playbackState.points.length : 0);
            updatePlaybackButtonsState('idle'); // 播放结束后按钮回到初始状态：开始可点，继续/结束灰化
            return;
        }
        const next = playbackState.points[playbackState.idx+1];
        const speed = playbackState.speed || 1;
        const delay = Math.max(4, Math.round(1000 / speed)); // 1x=1000ms/点，2x=500ms/点...
        console.log('[Playback] scheduleNext: idx=', playbackState.idx, '->', playbackState.idx+1, 'delay=', delay, 'speed=', speed);
        playbackState.timer = setTimeout(()=>{
            playbackState.idx++;
            const nextLL = next.ll;
            console.log('[Playback] 下一点:', next && next.ts, nextLL);
            try {
                // 维护路径数组
                playbackState.path = playbackState.path || [];
                playbackState.path.push(nextLL);
                console.log('[Playback] 路径长度=', playbackState.path.length);
                // 使用DOM标记进行移动（容器/图层坐标）
                if (!playbackDom.el) console.log('[Playback] DOM标记不存在，将尝试创建');
                updatePlaybackDom(nextLL);
                // 折线更新：优先setLngLats，兜底重建
                if (playbackState.line && typeof playbackState.line.setLngLats === 'function') {
                    try { playbackState.line.setLngLats(playbackState.path); }
                    catch(e){
                        console.warn('[Playback] setLngLats失败，重建折线', e);
                        if (map) { try { map.removeOverLay(playbackState.line); } catch(e){} }
                        playbackState.line = new T.Polyline(playbackState.path, { color: currentTrackLineColor, weight: 1, opacity: 0.9 });
                        if (map) map.addOverLay(playbackState.line);
                    }
                } else {
                    console.log('[Playback] 折线不支持setLngLats，重建');
                    if (playbackState.line && map) { try { map.removeOverLay(playbackState.line); } catch(e){} }
                    playbackState.line = new T.Polyline(playbackState.path, { color: currentTrackLineColor, weight: 1, opacity: 0.9 });
                    if (map) map.addOverLay(playbackState.line);
                }
            } catch(e) { console.warn('更新回放覆盖物失败:', e); }
            updatePlaybackTimeLabel(next.ts);
            scheduleNext();
        }, delay);
    }

    function stopPlayback(){
        if (playbackState.timer) { clearTimeout(playbackState.timer); playbackState.timer = null; }
        playbackState.running = false;
        playbackState.idx = 0;
        try {
            // 移除DOM标记
            removePlaybackDom();
            if (playbackState.marker && map) map.removeOverLay(playbackState.marker);
            if (playbackState.line && map) map.removeOverLay(playbackState.line);
        } catch(e){}
        playbackState.marker = null;
        playbackState.line = null;
        updatePlaybackTimeLabel('—');
        // 按钮回到初始状态
        updatePlaybackButtonsState('idle');
    }

    function updatePlaybackTimeLabel(text){
        const el = document.getElementById('playbackTimeLabel');
        if (el) el.textContent = '时间：' + (text || '—');
    }

    // 时间滑动条：配置与跳转
    function configureTimeSlider(points){
        try {
            const slider = document.getElementById('playbackTimeSlider');
            const cursor = document.getElementById('playbackTimeCursor');
            if (!slider || !points || !points.length) return;
            const minMs = points[0].time.getTime();
            const maxMs = points[points.length - 1].time.getTime();
            const prev = parseInt(slider.value, 10);
            slider.min = String(minMs);
            slider.max = String(maxMs);
            slider.step = '1000'; // 以秒为步进
            let val = (isFinite(prev) && prev >= minMs && prev <= maxMs) ? prev : minMs;
            slider.value = String(val);
            if (cursor) cursor.textContent = formatTimeForLabel(val);
        } catch(e) { console.warn('配置时间滑动条失败:', e); }
    }
    function formatTimeForLabel(ms){
        if (!isFinite(ms)) return '—';
        const d = new Date(ms);
        const pad = n => String(n).padStart(2,'0');
        const y = d.getFullYear();
        const M = pad(d.getMonth()+1);
        const da = pad(d.getDate());
        const h = pad(d.getHours());
        const m = pad(d.getMinutes());
        const s = pad(d.getSeconds());
        return `${y}-${M}-${da} ${h}:${m}:${s}`;
    }
    function findIndexByTime(points, ms){
        try {
            if (!points || !points.length) return 0;
            const n = points.length;
            const minMs = points[0].time.getTime();
            const maxMs = points[n-1].time.getTime();
            if (!isFinite(ms)) return 0;
            if (ms <= minMs) return 0;
            if (ms >= maxMs) return n-1;
            let lo = 0, hi = n - 1, ans = 0;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const t = points[mid].time.getTime();
                if (t < ms) { lo = mid + 1; ans = lo; }
                else { hi = mid - 1; ans = mid; }
            }
            return Math.max(0, Math.min(n-1, ans));
        } catch(e){ console.warn('findIndexByTime失败:', e); return 0; }
    }
    function jumpToSliderTime(){
        try {
            const slider = document.getElementById('playbackTimeSlider');
            if (!slider || !playbackState.points || !playbackState.points.length) return;
            const ms = parseInt(slider.value, 10);
            if (!isFinite(ms)) return;
            const idx = findIndexByTime(playbackState.points, ms);
            playbackState.idx = idx;
            const pts = playbackState.points;
            const ll = pts[idx].ll;
            playbackState.path = pts.slice(0, idx+1).map(p=>p.ll);
            // 更新折线
            try {
                if (playbackState.line && typeof playbackState.line.setLngLats === 'function') {
                    playbackState.line.setLngLats(playbackState.path);
                } else {
                    if (playbackState.line && map) { try { map.removeOverLay(playbackState.line); } catch(e){} }
                    playbackState.line = new T.Polyline(playbackState.path, { color: currentTrackLineColor, weight: 1, opacity: 0.9 });
                    if (map) map.addOverLay(playbackState.line);
                }
            } catch(e){ console.warn('滑块更新折线失败:', e); }
            // 更新标记与时间
            ensurePlaybackDom(ll);
            updatePlaybackDom(ll);
            updatePlaybackTimeLabel(pts[idx].ts);
            // 若正在播放，立即按新位置继续
            if (playbackState.running) {
                if (playbackState.timer) { clearTimeout(playbackState.timer); playbackState.timer = null; }
                scheduleNext();
            }
        } catch(e) { console.warn('滑块跳转失败:', e); }
    }

    // DOM标记：使用容器坐标实现可见移动
    let playbackDom = { el: null, lastLL: null, bound: false };

    function ensurePlaybackDom(ll){
        try {
            playbackDom.lastLL = ll;
            const pane = (map && map.getPanes && map.getPanes().overlayPane) || document.getElementById('mapContainer');
            if (!pane) { console.warn('未找到overlayPane或mapContainer'); return; }
            if (!playbackDom.el) {
                const el = document.createElement('div');
                el.id = 'playbackDomMarker';
                el.style.position = 'absolute';
                el.style.width = '0';
                el.style.height = '0';
                el.style.borderLeft = '3px solid transparent';
                el.style.borderRight = '3px solid transparent';
                el.style.borderBottom = '4px solid #2C64A7';
                el.style.borderTop = '0';
                el.style.transform = 'translate(-50%, -50%)';
                el.style.zIndex = '9999';
                // 添加伪元素来增强箭头效果
                el.style.clipPath = 'polygon(50% 0, 100% 100%, 0 100%)';
                pane.appendChild(el);
                playbackDom.el = el;
                console.log('[Playback] 创建DOM标记，父节点=', pane === document.getElementById('mapContainer') ? '#mapContainer' : 'overlayPane');
                bindPlaybackDomEvents();
            }
            updatePlaybackDom(ll);
        } catch(e) { console.warn('创建DOM标记失败:', e); }
    }

    function updatePlaybackDom(ll){
        try {
            playbackDom.lastLL = ll;
            if (!map || !playbackDom.el || !ll) { console.log('[Playback] update取消：map/el/ll缺失'); return; }
            let p;
            if (typeof map.lngLatToLayerPoint === 'function') {
                p = map.lngLatToLayerPoint(ll);
                console.log('[Playback] 使用layerPoint定位:', ll && ll.lng, ll && ll.lat, '=>', p && p.x, p && p.y);
            } else if (typeof map.lngLatToContainerPoint === 'function') {
                p = map.lngLatToContainerPoint(ll);
                console.log('[Playback] 使用containerPoint定位:', ll && ll.lng, ll && ll.lat, '=>', p && p.x, p && p.y);
            } else {
                console.warn('地图对象不支持lngLat到像素坐标转换');
                return;
            }
            playbackDom.el.style.left = p.x + 'px';
            playbackDom.el.style.top = p.y + 'px';
        } catch(e) { console.warn('更新DOM标记位置失败:', e); }
    }

    function bindPlaybackDomEvents(){
        if (playbackDom.bound) return;
        const updater = function(){
            try {
                if (!map || !playbackDom.el || !playbackDom.lastLL) return;
                let p;
                if (typeof map.lngLatToLayerPoint === 'function') {
                    p = map.lngLatToLayerPoint(playbackDom.lastLL);
                } else if (typeof map.lngLatToContainerPoint === 'function') {
                    p = map.lngLatToContainerPoint(playbackDom.lastLL);
                }
                if (!p) return;
                playbackDom.el.style.left = p.x + 'px';
                playbackDom.el.style.top = p.y + 'px';
            } catch(e){}
        };
        try {
            map.addEventListener('move', updater);
            map.addEventListener('zoom', updater);
            playbackDom.bound = true;
        } catch(e){}
    }

    function removePlaybackDom(){
        try {
            const el = playbackDom.el;
            playbackDom.lastLL = null;
            if (el && el.parentNode) el.parentNode.removeChild(el);
        } catch(e){}
        playbackDom.el = null;
        playbackDom.bound = false;
    }

    // 测量功能相关变量
    let measureState = {
        isActive: false,
        mode: '', // 'distance' or 'area'
        points: [],
        tempLine: null,
        lines: [],
        markers: [],
        labels: [],
        polygon: null,
        areaLabel: null
    };

    // 绑定测量按钮事件
    function bindMeasureEvents() {
        const distanceBtn = document.getElementById('measureDistanceBtn');
        const areaBtn = document.getElementById('measureAreaBtn');
        
        if (distanceBtn) {
            distanceBtn.addEventListener('click', function() {
                startMeasureDistance();
            });
        }
        
        if (areaBtn) {
            areaBtn.addEventListener('click', function() {
                startMeasureArea();
            });
        }
    }

    // 绑定地图类型切换按钮事件
    function bindMapTypeEvent() {
        const mapTypeBtn = document.getElementById('mapTypeBtn');
        
        if (mapTypeBtn) {
            mapTypeBtn.addEventListener('click', function() {
                toggleMapType();
            });
        }
    }

    // 切换地图类型
    function toggleMapType() {
        if (!map) {
            alert('地图未初始化');
            return;
        }
        
        // 切换地图类型
        if (currentMapType === 'satellite') {
            // 切换到街道地图
            map.setMapType(TMAP_NORMAL_MAP);
            currentMapType = 'street';
            updateMapTypeButton('街道图');
        } else {
            // 切换到卫星地图
            map.setMapType(TMAP_SATELLITE_MAP);
            currentMapType = 'satellite';
            updateMapTypeButton('卫星图');
        }
    }

    // 更新地图类型按钮显示
    function updateMapTypeButton(typeName) {
        const mapTypeBtn = document.getElementById('mapTypeBtn');
        if (mapTypeBtn) {
            mapTypeBtn.innerHTML = `<span>${typeName}</span>`;
            mapTypeBtn.title = `当前：${typeName}，点击切换`;
        }
    }

    // 开始测距
    function startMeasureDistance() {
        if (!map) {
            alert('地图未初始化');
            return;
        }
        
        // 先移除所有可能存在的事件监听器
        try {
            map.removeEventListener('click', handleMapClick);
            map.removeEventListener('click', handleAreaMapClick);
            map.removeEventListener('mousemove', handleMouseMove);
            map.removeEventListener('mousemove', handleAreaMouseMove);
            map.removeEventListener('dblclick', finishMeasure);
            map.removeEventListener('dblclick', finishAreaMeasure);
        } catch(e) {
            console.log('移除事件监听器时出错:', e);
        }
        
        // 重置测量状态
        clearMeasureResult();
        
        // 设置测量状态为激活
        measureState.isActive = true;
        measureState.mode = 'distance'; // 设置为距离测量模式
        
        // 禁用其他按钮
        disableButtons(true);
        
        // 添加地图点击事件监听器
        map.addEventListener('click', handleMapClick);
        
        // 添加鼠标移动事件监听器
        map.addEventListener('mousemove', handleMouseMove);
        
        // 添加双击事件监听器结束测量
        map.addEventListener('dblclick', finishMeasure);
        
        console.log('测距功能已启动');
    }

    // 开始测面
    function startMeasureArea() {
        if (!map) {
            alert('地图未初始化');
            return;
        }
        
        // 先移除所有可能存在的事件监听器
        try {
            map.removeEventListener('click', handleMapClick);
            map.removeEventListener('click', handleAreaMapClick);
            map.removeEventListener('mousemove', handleMouseMove);
            map.removeEventListener('mousemove', handleAreaMouseMove);
            map.removeEventListener('dblclick', finishMeasure);
            map.removeEventListener('dblclick', finishAreaMeasure);
        } catch(e) {
            console.log('移除事件监听器时出错:', e);
        }
        
        // 重置测量状态
        clearMeasureResult();
        
        // 设置测量状态为激活
        measureState.isActive = true;
        measureState.mode = 'area'; // 设置为面积测量模式
        
        // 禁用其他按钮
        disableButtons(true);
        
        // 添加地图点击事件监听器
        map.addEventListener('click', handleAreaMapClick);
        
        // 添加鼠标移动事件监听器
        map.addEventListener('mousemove', handleAreaMouseMove);
        
        // 添加双击事件监听器结束测量
        map.addEventListener('dblclick', finishAreaMeasure);
        
        console.log('测面功能已启动');
    }

    // 处理地图点击事件
    function handleMapClick(event) {
        if (!measureState.isActive || measureState.mode !== 'distance') return;
        
        const point = event.lnglat;
        measureState.points.push(point);
        
        // 创建小圆点图标
        const smallDotIcon = new T.Icon({
            iconUrl: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><circle cx="4" cy="4" r="3" fill="%23FF0000" stroke="%23FFFFFF" stroke-width="1"/></svg>',
            iconSize: new T.Point(8, 8),
            iconAnchor: new T.Point(4, 4)
        });
        
        // 创建点标记
        const marker = new T.Marker(point, {icon: smallDotIcon});
        map.addOverLay(marker);
        measureState.markers.push(marker);
        
        // 如果不是第一个点，创建线段
        if (measureState.points.length > 1) {
            const prevPoint = measureState.points[measureState.points.length - 2];
            const line = new T.Polyline([prevPoint, point], {
                color: '#FF0000',
                weight: 3,
                opacity: 0.8
            });
            map.addOverLay(line);
            measureState.lines.push(line);
            
            // 计算距离并显示标签
            const distance = calculateDistance(prevPoint, point);
            showDistanceLabel(point, distance);
        }
        
        // 移除临时线
        if (measureState.tempLine) {
            map.removeOverLay(measureState.tempLine);
            measureState.tempLine = null;
        }
    }

    // 处理测面地图点击事件
    function handleAreaMapClick(event) {
        if (!measureState.isActive || measureState.mode !== 'area') return;
        
        const point = event.lnglat;
        measureState.points.push(point);
        
        // 创建小圆点图标（与测距功能一致）
        const smallDotIcon = new T.Icon({
            iconUrl: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><circle cx="4" cy="4" r="3" fill="%23FF0000" stroke="%23FFFFFF" stroke-width="1"/></svg>',
            iconSize: new T.Point(8, 8),
            iconAnchor: new T.Point(4, 4)
        });
        
        // 创建点标记
        const marker = new T.Marker(point, {icon: smallDotIcon});
        map.addOverLay(marker);
        measureState.markers.push(marker);
        
        // 移除之前的多边形
        if (measureState.polygon) {
            map.removeOverLay(measureState.polygon);
        }
        
        // 如果点数大于2，创建多边形
        if (measureState.points.length >= 3) {
            const polygon = new T.Polygon(measureState.points, {
                color: currentOutlineColor,
                weight: 3,
                opacity: 0.8,
                fillColor: currentFillColor,
                fillOpacity: currentFillOpacity
            });
            map.addOverLay(polygon);
            measureState.polygon = polygon;
            
            // 计算面积并显示标签
            const area = calculatePolygonArea(measureState.points);
            showAreaLabel(getPolygonCenter(measureState.points), area);
        }
        
        // 移除临时线
        if (measureState.tempLine) {
            map.removeOverLay(measureState.tempLine);
            measureState.tempLine = null;
        }
    }

    // 处理鼠标移动事件
    function handleMouseMove(event) {
        if (!measureState.isActive || measureState.mode !== 'distance' || measureState.points.length === 0) return;
        
        const lastPoint = measureState.points[measureState.points.length - 1];
        const currentPoint = event.lnglat;
        
        // 移除之前的临时线
        if (measureState.tempLine) {
            map.removeOverLay(measureState.tempLine);
        }
        
        // 创建新的临时线
        measureState.tempLine = new T.Polyline([lastPoint, currentPoint], {
            color: '#0000FF',
            weight: 2,
            opacity: 0.6,
            dashArray: [5, 5]
        });
        map.addOverLay(measureState.tempLine);
    }

    // 处理测面鼠标移动事件
    function handleAreaMouseMove(event) {
        if (!measureState.isActive || measureState.mode !== 'area' || measureState.points.length === 0) return;
        
        const firstPoint = measureState.points[0];
        const lastPoint = measureState.points[measureState.points.length - 1];
        const currentPoint = event.lnglat;
        
        // 移除之前的临时线
        if (measureState.tempLine) {
            map.removeOverLay(measureState.tempLine);
        }
        
        // 创建新的临时线（从最后一个点到当前点，再到第一个点形成闭合效果）
        const tempPoints = [lastPoint, currentPoint];
        if (measureState.points.length >= 2) {
            tempPoints.push(firstPoint);
        }
        
        measureState.tempLine = new T.Polyline(tempPoints, {
            color: '#0000FF',
            weight: 2,
            opacity: 0.6,
            dashArray: [5, 5]
        });
        map.addOverLay(measureState.tempLine);
    }

    // 结束测量
    function finishMeasure() {
        if (!measureState.isActive || measureState.mode !== 'distance') return;
        
        // 移除事件监听器
        map.removeEventListener('click', handleMapClick);
        map.removeEventListener('mousemove', handleMouseMove);
        map.removeEventListener('dblclick', finishMeasure);
        
        // 移除临时线
        if (measureState.tempLine) {
            map.removeOverLay(measureState.tempLine);
            measureState.tempLine = null;
        }
        
        // 显示总距离
        if (measureState.points.length > 1) {
            const totalDistance = calculateTotalDistance();
            showTotalDistanceLabel(totalDistance);
        }
        
        // 重置测量状态
        measureState.isActive = false;
        measureState.mode = '';
        
        // 恢复其他按钮
        disableButtons(false);
        
        console.log('测距功能已完成');
    }

    // 结束测面测量
    function finishAreaMeasure() {
        if (!measureState.isActive || measureState.mode !== 'area') return;
        
        // 移除事件监听器
        map.removeEventListener('click', handleAreaMapClick);
        map.removeEventListener('mousemove', handleAreaMouseMove);
        map.removeEventListener('dblclick', finishAreaMeasure);
        
        // 移除临时线
        if (measureState.tempLine) {
            map.removeOverLay(measureState.tempLine);
            measureState.tempLine = null;
        }
        
        // 如果点数大于等于3，创建最终多边形
        if (measureState.points.length >= 3) {
            // 移除之前的多边形
            if (measureState.polygon) {
                map.removeOverLay(measureState.polygon);
            }
            
            const polygon = new T.Polygon(measureState.points, {
                color: currentOutlineColor,
                weight: 3,
                opacity: 0.8,
                fillColor: currentFillColor,
                fillOpacity: currentFillOpacity
            });
            map.addOverLay(polygon);
            measureState.polygon = polygon;
            
            // 计算并显示总面积
            const area = calculatePolygonArea(measureState.points);
            showTotalAreaLabel(getPolygonCenter(measureState.points), area);
        } else {
            // 点数不足3个，移除所有标记
            clearMeasureResult();
        }
        
        // 重置测量状态
        measureState.isActive = false;
        measureState.mode = '';
        
        // 恢复其他按钮
        disableButtons(false);
        
        console.log('测面功能已完成');
    }

    // 计算两点间距离（米）
    function calculateDistance(point1, point2) {
        // 使用天地图提供的距离计算方法
        if (T.CRS && T.CRS.EPSG4326 && T.CRS.EPSG4326.distance) {
            return T.CRS.EPSG4326.distance(point1, point2);
        }
        
        // 如果没有提供，则使用球面距离公式
        const R = 6371000; // 地球半径（米）
        const dLat = (point2.lat - point1.lat) * Math.PI / 180;
        const dLon = (point2.lng - point1.lng) * Math.PI / 180;
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) * 
            Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // 计算多边形面积（平方米）
    function calculatePolygonArea(points) {
        // 使用天地图提供的面积计算方法（如果可用）
        if (T.GeometryUtils && T.GeometryUtils.computeArea) {
            return T.GeometryUtils.computeArea(points);
        }
        
        // 如果没有提供，则使用球面多边形面积计算公式
        // 这里使用简单的平面近似计算，对于小面积比较准确
        if (points.length < 3) return 0;
        
        let area = 0;
        const n = points.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += points[i].lng * points[j].lat;
            area -= points[j].lng * points[i].lat;
        }
        
        area = Math.abs(area) / 2.0;
        
        // 转换为平方米（这是一个简化的近似值）
        // 更精确的计算需要考虑地球曲率
        const earthRadius = 6371000; // 地球半径（米）
        const degreeToMeter = (2 * Math.PI * earthRadius) / 360; // 每度对应的米数
        
        // 这个转换只是一个粗略的近似
        return area * degreeToMeter * degreeToMeter;
    }

    // 获取多边形中心点
    function getPolygonCenter(points) {
        if (points.length === 0) return null;
        
        let x = 0, y = 0;
        for (let i = 0; i < points.length; i++) {
            x += points[i].lng;
            y += points[i].lat;
        }
        
        return new T.LngLat(x / points.length, y / points.length);
    }

    // 计算总距离
    function calculateTotalDistance() {
        let total = 0;
        for (let i = 1; i < measureState.points.length; i++) {
            const distance = calculateDistance(measureState.points[i-1], measureState.points[i]);
            total += distance;
        }
        return total;
    }

    // 显示两点间距离标签
    function showDistanceLabel(point, distance) {
        const label = document.createElement('div');
        label.className = 'distance-label';
        label.innerHTML = distance.toFixed(2) + ' 米';
        label.style.position = 'absolute';
        label.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        label.style.padding = '2px 6px';
        label.style.borderRadius = '3px';
        label.style.fontSize = '12px';
        label.style.boxShadow = '0 1px 2px rgba(0,0,0,0.3)';
        label.style.zIndex = '1000';
        label.style.transform = 'translate(-50%, -50%)';
        
        // 添加删除按钮
        const closeBtn = document.createElement('span');
        closeBtn.innerHTML = '×';
        closeBtn.style.marginLeft = '5px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.onclick = function() {
            if (label.parentNode) {
                label.parentNode.removeChild(label);
            }
        };
        label.appendChild(closeBtn);
        
        document.getElementById('mapContainer').appendChild(label);
        
        // 定位标签（向上偏移20像素）
        const pixel = map.lngLatToContainerPoint(point);
        label.style.left = pixel.x + 'px';
        label.style.top = (pixel.y - 20) + 'px';
        
        measureState.labels.push(label);
    }

    // 显示面积标签
    function showAreaLabel(point, area) {
        // 如果已存在面积标签，先移除它
        if (measureState.areaLabel) {
            if (measureState.areaLabel.parentNode) {
                measureState.areaLabel.parentNode.removeChild(measureState.areaLabel);
            }
        }
        
        const label = document.createElement('div');
        label.className = 'area-label';
        label.innerHTML = area.toFixed(2) + ' 平方米';
        label.style.position = 'absolute';
        label.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        label.style.padding = '2px 6px';
        label.style.borderRadius = '3px';
        label.style.fontSize = '12px';
        label.style.boxShadow = '0 1px 2px rgba(0,0,0,0.3)';
        label.style.zIndex = '1000';
        label.style.transform = 'translate(-50%, -50%)';
        
        // 添加删除按钮
        const closeBtn = document.createElement('span');
        closeBtn.innerHTML = '×';
        closeBtn.style.marginLeft = '5px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.onclick = function() {
            if (label.parentNode) {
                label.parentNode.removeChild(label);
            }
        };
        label.appendChild(closeBtn);
        
        document.getElementById('mapContainer').appendChild(label);
        
        // 定位标签
        const pixel = map.lngLatToContainerPoint(point);
        label.style.left = pixel.x + 'px';
        label.style.top = (pixel.y - 20) + 'px';
        
        measureState.areaLabel = label;
        measureState.labels.push(label);
    }

    // 显示总面积标签
    function showTotalAreaLabel(point, area) {
        // 如果已存在面积标签，先移除它
        if (measureState.areaLabel) {
            if (measureState.areaLabel.parentNode) {
                measureState.areaLabel.parentNode.removeChild(measureState.areaLabel);
            }
        }
        
        // 计算亩数（1亩 ≈ 666.6667平方米）
        const areaInMu = area / 666.6667;
        
        const label = document.createElement('div');
        label.className = 'total-area-label';
        label.innerHTML = '总面积: ' + area.toFixed(2) + ' 平方米<br>' + areaInMu.toFixed(2) + ' 亩';
        label.style.position = 'absolute';
        label.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        label.style.color = 'white';
        label.style.padding = '4px 8px';
        label.style.borderRadius = '4px';
        label.style.fontSize = '14px';
        label.style.fontWeight = 'bold';
        label.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
        label.style.zIndex = '1000';
        label.style.transform = 'translate(-50%, -50%)';
        label.style.lineHeight = '1.4';
        
        // 添加删除按钮
        const closeBtn = document.createElement('span');
        closeBtn.innerHTML = ' ×';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.onclick = function() {
            if (label.parentNode) {
                label.parentNode.removeChild(label);
            }
        };
        label.appendChild(closeBtn);
        
        document.getElementById('mapContainer').appendChild(label);
        
        // 定位标签
        const pixel = map.lngLatToContainerPoint(point);
        label.style.left = pixel.x + 'px';
        label.style.top = (pixel.y - 40) + 'px';
        
        measureState.areaLabel = label;
        measureState.labels.push(label);
    }

    // 显示总距离标签
    function showTotalDistanceLabel(totalDistance) {
        const lastPoint = measureState.points[measureState.points.length - 1];
        const label = document.createElement('div');
        label.className = 'total-distance-label';
        label.innerHTML = '总距离: ' + totalDistance.toFixed(2) + ' 米';
        label.style.position = 'absolute';
        label.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        label.style.color = 'white';
        label.style.padding = '4px 8px';
        label.style.borderRadius = '4px';
        label.style.fontSize = '14px';
        label.style.fontWeight = 'bold';
        label.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
        label.style.zIndex = '1000';
        label.style.transform = 'translate(-50%, -50%)';
        
        // 添加删除按钮
        const closeBtn = document.createElement('span');
        closeBtn.innerHTML = ' ×';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.onclick = function() {
            if (label.parentNode) {
                label.parentNode.removeChild(label);
            }
        };
        label.appendChild(closeBtn);
        
        document.getElementById('mapContainer').appendChild(label);
        
        // 定位标签（向上偏移40像素，比段距离标签更高）
        const pixel = map.lngLatToContainerPoint(lastPoint);
        label.style.left = pixel.x + 'px';
        label.style.top = (pixel.y - 60) + 'px';  // 从-40改为-60，增加间距
        
        measureState.labels.push(label);
    }

    // 清除测量结果
    function clearMeasureResult() {
        // 移除所有线条
        measureState.lines.forEach(line => {
            if (map && map.removeOverLay) {
                try { map.removeOverLay(line); } catch(e) {}
            }
        });
        
        // 移除所有标记
        measureState.markers.forEach(marker => {
            if (map && map.removeOverLay) {
                try { map.removeOverLay(marker); } catch(e) {}
            }
        });
        
        // 移除所有标签
        measureState.labels.forEach(label => {
            if (label.parentNode) {
                try { label.parentNode.removeChild(label); } catch(e) {}
            }
        });
        
        // 移除临时线
        if (measureState.tempLine) {
            if (map && map.removeOverLay) {
                try { map.removeOverLay(measureState.tempLine); } catch(e) {}
            }
            measureState.tempLine = null;
        }
        
        // 移除多边形
        if (measureState.polygon) {
            if (map && map.removeOverLay) {
                try { map.removeOverLay(measureState.polygon); } catch(e) {}
            }
            measureState.polygon = null;
        }
        
        // 移除面积标签
        if (measureState.areaLabel) {
            if (measureState.areaLabel.parentNode) {
                try { measureState.areaLabel.parentNode.removeChild(measureState.areaLabel); } catch(e) {}
            }
            measureState.areaLabel = null;
        }
        
        // 重置状态
        measureState.points = [];
        measureState.lines = [];
        measureState.markers = [];
        measureState.labels = [];
        measureState.isActive = false;
        measureState.mode = '';
    }

    // 添加CSS样式用于距离标签
    const style = document.createElement('style');
    style.innerHTML = `
        .distance-label, .total-distance-label {
            font-family: Arial, sans-serif;
            pointer-events: auto;
        }
    `;
    document.head.appendChild(style);

    // 颜色选择器相关变量和函数
    let currentOutlineColor = "#FFD700"; // 默认边框颜色
    let currentFillColor = "#FFFF00";   // 默认填充颜色
    let currentFillOpacity = 0.35;       // 默认透明度
    
    // 轨迹颜色相关变量
    let currentTrackLineColor = "#FF0000"; // 默认轨迹线颜色
    let currentTrackPointColor = "#68EAF3"; // 默认轨迹点颜色

    // 初始化颜色选择器
    function initColorPickers() {
        // 边框颜色选择器
        const outlineColorPicker = document.getElementById('outlineColorPicker');
        const outlineColorInput = document.getElementById('outlineColorInput');
        
        outlineColorPicker.addEventListener('click', function() {
            outlineColorInput.click();
        });
        
        outlineColorInput.addEventListener('change', function() {
            currentOutlineColor = this.value;
            outlineColorPicker.style.backgroundColor = currentOutlineColor;
        });
        
        // 填充颜色选择器
        const fillColorPicker = document.getElementById('fillColorPicker');
        const fillColorInput = document.getElementById('fillColorInput');
        
        fillColorPicker.addEventListener('click', function() {
            fillColorInput.click();
        });
        
        fillColorInput.addEventListener('change', function() {
            currentFillColor = this.value;
            fillColorPicker.style.backgroundColor = currentFillColor;
        });
        
        // 透明度滑块
        const fillOpacitySlider = document.getElementById('fillOpacitySlider');
        const fillOpacityValue = document.getElementById('fillOpacityValue');
        
        fillOpacitySlider.addEventListener('input', function() {
            currentFillOpacity = this.value / 100;
            fillOpacityValue.textContent = this.value + '%';
        });
        
        // 轨迹线颜色选择器
        const trackLineColorPicker = document.getElementById('trackLineColorPicker');
        const trackLineColorInput = document.getElementById('trackLineColorInput');
        
        if (trackLineColorPicker && trackLineColorInput) {
            trackLineColorPicker.addEventListener('click', function() {
                trackLineColorInput.click();
            });
            
            trackLineColorInput.addEventListener('change', function() {
                currentTrackLineColor = this.value;
                trackLineColorPicker.style.backgroundColor = currentTrackLineColor;
            });
        }
        
        // 轨迹点颜色选择器
        const trackPointColorPicker = document.getElementById('trackPointColorPicker');
        const trackPointColorInput = document.getElementById('trackPointColorInput');
        
        if (trackPointColorPicker && trackPointColorInput) {
            // 设置初始背景色
            trackPointColorPicker.style.backgroundColor = currentTrackPointColor;
            
            trackPointColorPicker.addEventListener('click', function() {
                trackPointColorInput.click();
            });
            
            trackPointColorInput.addEventListener('change', function() {
                currentTrackPointColor = this.value;
                trackPointColorPicker.style.backgroundColor = currentTrackPointColor;
            });
        }
    }

</script>
</body>

</html>
