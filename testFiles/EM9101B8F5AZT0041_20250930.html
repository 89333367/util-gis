<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>展示轮廓</title>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #mapContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #mapLoading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.3s;
        }

        .loading-text {
            font-size: 16px;
            color: #333;
            padding: 10px 20px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .wkt-input-container {
            position: absolute;
            top: 20px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            width: min(320px, 90vw);
            box-sizing: border-box;
            transition: all 0.3s;
        }

        .minimize-btn {
            position: absolute;
            top: -5px;
            right: -4px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #666;
            z-index: 1001;
            transition: background 0.2s;
        }

        .minimize-btn:hover {
            background: #e0e0e0;
        }

        .content-wrapper {
            transition: all 0.3s;
        }

        .wkt-input-container.minimized {
            width: 40px;
            height: 40px;
            padding: 0;
        }

        .wkt-input-container.minimized .content-wrapper {
            display: none;
        }

        .wkt-input-container.minimized .min-icon {
            display: none;
        }

        .wkt-input-container.minimized .restore-icon {
            display: inline;
        }

        #wktTextarea {
            width: 100%;
            height: 120px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        /* 页签样式 */
        .tabs-header {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        .tab-btn {
            flex: 1;
            padding: 6px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            background: #f5f5f5;
            color: #333;
            transition: background 0.2s;
        }
        .tab-btn.active { background: #337AFF; color: #fff; }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }

        /* Multi → Polygons 分割器样式 */
        .split-section {
            margin-top: 10px;
            padding: 10px;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 6px;
        }
        .split-section .title {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
        }
        .split-section .desc {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }
        #multiInput, #polyOutput {
            width: 100%;
            height: 90px;
            margin-bottom: 8px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        }
        .split-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        .split-actions button {
            flex: 1;
            padding: 6px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        #splitMultiBtn { background: #337AFF; color: #fff; }
        #splitMultiBtn:hover { background: #2860E0; }
        #copyPolysBtn { background: #f5f5f5; color: #333; }
        #copyPolysBtn:hover { background: #e0e0e0; }
        #drawButton,
        #clearButton,
        #drawTrackButton,
        #clearTrackButton {
            width: 50%;
            padding: 8px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        #drawButton,
        #drawTrackButton {
            background: #337AFF;
            color: white;
        }

        #drawButton:hover,
        #drawTrackButton:hover {
            background: #2860E0;
        }

        #clearButton,
        #clearTrackButton {
            background: #f5f5f5;
            color: #333;
        }

        #clearButton:hover,
        #clearTrackButton:hover {
            background: #e0e0e0;
        }

        #drawButton:disabled,
        #clearButton:disabled,
        #drawTrackButton:disabled,
        #clearTrackButton:disabled {
            background: #e0e0e0;
            color: #999;
            cursor: not-allowed;
        }

        .tip {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .area-label {
             position: absolute;
             background: rgba(255, 0, 0, 0.85);
             border: 1px solid #000;
             border-radius: 3px;
             padding: 4px 6px;
             font-size: 12px;
             color: #fff;
             font-weight: 600;
             box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
             white-space: nowrap;
             z-index: 9999;
             pointer-events: none;
         }
         /* 默认隐藏标签容器下的标签 */
          .labels-hidden .area-label { display: none; }

          /* Batch → Generator 样式 */
          .batch-section { margin-top: 10px; padding: 10px; background: #fafafa; border: 1px solid #eee; border-radius: 6px; }
          .batch-section .title { font-size: 13px; font-weight: 600; color: #333; margin-bottom: 6px; }
          .batch-section .desc { font-size: 12px; color: #666; margin-bottom: 8px; }
          #batchInput, #multiOutput { width: 100%; height: 90px; margin-bottom: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; resize: vertical; box-sizing: border-box; }
          .batch-actions { display: flex; gap: 8px; margin-bottom: 8px; }
          .batch-actions button { flex: 1; padding: 6px 0; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; transition: background 0.2s; }
          #generateMultiBtn { background: #337AFF; color: #fff; }
          #generateMultiBtn:hover { background: #2860E0; }
          #copyMultiBtn { background: #f5f5f5; color: #333; }
          #copyMultiBtn:hover { background: #e0e0e0; }
      </style>
    <script src="https://api.tianditu.gov.cn/api?v=4.0&tk=648f621977051d0199ff0f965d3fd322"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://lib.baomitu.com/terraformer/1.0.12/terraformer.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://unpkg.com/terraformer-wkt-parser@1.2.1/terraformer-wkt-parser.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- 已移除动态备用加载器 ensureTerraformer：改为仅使用静态脚本标签加载 Terraformer 核心库与 WKT 解析器 -->
    <script>
        // 检查Turf.js是否加载成功
        window.addEventListener('load', function () {
            if (typeof turf === 'undefined') {
                console.warn('Turf.js加载失败，已启用备用面积算法');
            } else {
                console.log('Turf.js加载成功');
            }
        });
    </script>
</head>

<body>
<div id="mapContainer">
    <div id="mapLoading">
        <div class="loading-text">地图正在加载中...</div>
    </div>
</div>

<div class="wkt-input-container">
    <div class="minimize-btn" id="minimizeBtn">
        <span class="min-icon">−</span>
        <span class="restore-icon" style="display:none;">+</span>
    </div>

    <div class="content-wrapper">
        <div class="tabs-header">
            <button class="tab-btn active" id="tabDrawBtn">轮廓</button>
            <button class="tab-btn" id="tabTrackBtn">轨迹</button>
            <button class="tab-btn" id="tabSplitBtn">分割器</button>
            <button class="tab-btn" id="tabBatchBtn">合并器</button>
        </div>
        <div class="tab-pane active" id="tabDraw">
            <div class="tip">请输入WKT字符串（支持POLYGON/MULTIPOLYGON）：</div>
            <textarea id="wktTextarea">MULTIPOLYGON (((124.50447181138274 45.34206334997412, 124.50445622439733 45.342082833703635, 124.50444678185265 45.342090774018445, 124.50444515720083 45.34209241805611, 124.50444397211646 45.34209423934415, 124.50444326423097 45.34209618004893, 124.50444232854247 45.34210020350744, 124.50443411178948 45.34211047443419, 124.50443270907432 45.34211280995571, 124.50443208424896 45.34211530776318, 124.50443226909975 45.34211784078658, 124.50443526538825 45.34213057503672, 124.50443326421933 45.342139180047724, 124.50443306558599 45.3421414285836, 124.50443350650367 45.34214365991767, 124.50443456927562 45.34214578449206, 124.50444117578829 45.34215569426644, 124.50444426908615 45.34216884078839, 124.5044450805886 45.342170969676765, 124.50444646543572 45.34217294601269, 124.50444837040881 45.34217469384664, 124.50445072230076 45.3421761460103, 124.50445343072964 45.342177246697865, 124.50445639161211 45.34217795361047, 124.50445949116308 45.34217823958181, 124.50446261026832 45.342178093622245, 124.50446562906238 45.342177521340844, 124.50446843153473 45.34217654473013, 124.50447090998766 45.34217520132071, 124.50447296917588 45.34217354273907, 124.50447452996575 45.34217163272358, 124.50447553237711 45.34216954467512, 124.50447593788786 45.342167358836214, 124.5044757309146 45.34216515920743, 124.50447539153247 45.34216371683655, 124.50447600141972 45.34216281287511, 124.50447676796855 45.342160675716876, 124.5044769285631 45.34215847416177, 124.50447647703189 45.342156292814366, 124.5044754307272 45.34215421550256, 124.50447191511452 45.34214894208677, 124.50446758841373 45.342130553630106, 124.5044728845702 45.34210778012781, 124.50448255345711 45.34209569402174, 124.50451521814962 45.34206822597355, 124.50451704547358 45.342066324189204, 124.50451828663986 45.34206420021132, 124.50451888985144 45.34206194267954, 124.50451882993438 45.34205964580707, 124.50451810938937 45.34205740544891, 124.50451675828694 45.34205531510154, 124.5045156135332 45.34205421326202, 124.50456111205935 45.34199323586704, 124.5045623077366 45.34199114961228, 124.50456289047742 45.34198893724405, 124.50456283694832 45.34198668734766, 124.50456214929274 45.34198449001115, 124.50456085504511 45.341982433217915, 124.50455900602839 45.34198059932393, 124.50455667627912 45.341979061760036, 124.50455395908264 45.341977882091726, 124.50455096323797 45.34197710755404, 124.50454780870156 45.34197676916018, 124.50418686853207 45.34196384293057, 124.50355458442736 45.34182199635738, 124.50329363593286 45.34173777469649, 124.50329280398695 45.341737526038074, 124.5029118040474 45.34163252605648, 124.5029087855983 45.34163192760002, 124.50290565944621 45.34163175724934, 124.50290254646147 45.341632021590925, 124.50289956700502 45.3416327104042, 124.50289683627543 45.34163379705676, 124.50289445985403 45.341635239534014, 124.50289252962347 45.34163698206371, 124.50257452957132 45.3419909820272, 124.50257362542294 45.341992132218714, 124.50236864234348 45.3422931700754, 124.5021116036221 45.34240543984611, 124.5021081458671 45.34240747845729, 124.50188902432349 45.34257922235062, 124.50141212158324 45.342687293852094, 124.50141002761171 45.342687886611486, 124.50137095430647 45.34270128324175, 124.50112357294226 45.34276442598287, 124.50112043086226 45.34276551635995, 124.5011177020511 45.34276706411022, 124.50111551811275 45.34276899458939, 124.50082351806454 45.343094994555834, 124.50082211573773 45.3430969647622, 124.50082128540467 45.343099090040496, 124.5008210589746 45.34310128871746, 124.50082144514933 45.34310347629918, 124.50082242908833 45.34310556871811, 124.50082397297945 45.343107485563735, 124.50082601749192 45.34310915317274, 124.50082848405621 45.343110507459826, 124.50083127788363 45.34311149638047, 124.50083429160895 45.34311208193101, 124.50083740941626 45.34311224160902, 124.50084051149001 45.343111969278176, 124.5008434786191 45.34311127540403, 124.50084619677837 45.34311018665175, 124.50084856151047 45.34310874486151, 124.50085048194016 45.343107005440544, 124.50111195012343 45.342815092460896, 124.50138338819774 45.342722028039184, 124.50141909542965 45.34271291390658, 124.50183869973024 45.3426620829778, 124.50184217926272 45.34266136667686, 124.50184533950731 45.34266011472061, 124.50184801717123 45.34265839179878, 124.50212764589634 45.34243230897069, 124.50235033539228 45.34236431969257, 124.50235306851793 45.34236324978253, 124.50235545314544 45.34236182440845, 124.50235739763485 45.34236009834669, 124.50235882726047 45.34235813792885, 124.50235968708279 45.342356018492715, 124.50235994405917 45.34235382148704, 124.50235958831446 45.342351631341515, 124.50235863351966 45.3423495322222, 124.50235711636704 45.342347604797055, 124.50235509515997 45.34234592313595, 124.50235264757238 45.34234455186414, 124.50234986766361 45.34234354367878, 124.50234686226396 45.34234293732389, 124.50234374686924 45.34234275610132, 124.50234064120227 45.34234300697535, 124.5023376646119 45.342343680305014, 124.502257612435 45.34236812108283, 124.50238939640856 45.34231056013187, 124.502391800009 45.34230927342001, 124.50239381682945 45.34230769041285, 124.50239537464181 45.34230586780247, 124.50260197027335 45.342002461547445, 124.50291243708631 45.341656847508176, 124.50328077504287 45.341758357945224, 124.50348659238472 45.3418247859874, 124.50348667973404 45.34182511906415, 124.50348783696397 45.34182716690682, 124.50348953847167 45.34182901618814, 124.50349171886907 45.341830595841245, 124.50349429436478 45.341831845160904, 124.50349716598389 45.34183271613646, 124.50354307229169 45.34184301492038, 124.50365836412159 45.341880225322186, 124.50365955701197 45.34188056991505, 124.50406955707926 45.34198556993356, 124.504072106785 45.341986058662826, 124.50433918081475 45.34202080807378, 124.50447181138274 45.34206334997412), (124.50160154382621 45.342667992231185, 124.50186870451941 45.342607450412586, 124.50182771076223 45.34264059414491, 124.50160154382621 45.342667992231185), (124.50427427460352 45.34198949288409, 124.50452126909319 45.341998338344126, 124.50448745714041 45.34204366072158, 124.50435060196767 45.34199976376163, 124.50434689316482 45.34199894132899, 124.50427427460352 45.34198949288409), (124.50405332596465 45.34195748553583, 124.50408791644278 45.341965245484644, 124.50407919687534 45.34196411095787, 124.50405332596465 45.34195748553583)), ((124.49844910597022 45.345816734235825, 124.4984346493929 45.34585295325119, 124.49843409117989 45.34585522166148, 124.49843419980756 45.345857522696924, 124.4984349707228 45.34585975990639, 124.49843637161176 45.345861839514015, 124.49843834375405 45.345863674350106, 124.49844080448469 45.345865187504856, 124.49844365065863 45.34586631555222, 124.49844676297441 45.345867011208476, 124.49845001097485 45.345867245314174, 124.4984532585152 45.34586700805645, 124.49846345112626 45.34586550776238, 124.4984683852318 45.3458822836993, 124.49846924332194 45.345884263160166, 124.49847060137269 45.345886098183946, 124.49847241337301 45.34588772659944, 124.49847461793179 45.34588909323547, 124.49847714035795 45.345890151789995, 124.49860214037565 45.34593215179721, 124.49860488424407 45.34593286433979, 124.49860776648366 45.34593321162479, 124.49861069019396 45.345933181976534, 124.49891669025327 45.34591018197129, 124.49891824884524 45.345910009476704, 124.49910224887914 45.34588300947107, 124.49910528494043 45.34588233514398, 124.49910807059857 45.34588124904657, 124.49911049486803 45.34587979445089, 124.49929049486497 45.34574779443297, 124.49929247243391 45.34574601674234, 124.49929390614359 45.34574399616606, 124.49935355340644 45.345633360068724, 124.49942956598893 45.345638199756245, 124.49943265421507 45.345638184649495, 124.49943568040094 45.345637750070196, 124.49943853105158 45.34563691231692, 124.49944109925536 45.34563570280907, 124.49944328869351 45.34563416690839, 124.49944501725261 45.34563236221777, 124.49944622010436 45.34563035642091, 124.49944685213671 45.345628224743834, 124.49944688964585 45.3456260471336, 124.49944633122493 45.345623905259956, 124.49944519781727 45.345621879452366, 124.49944353193062 45.34562004568729, 124.49944139604287 45.3456184727388, 124.49943887025903 45.345617219599205, 124.4994360493068 45.3456163332666, 124.49943303898404 45.34561584698225, 124.49942193165771 45.34561483821566, 124.49947863833246 45.3456132363021, 124.49948182209012 45.34561291755054, 124.49948485043352 45.34561215486848, 124.499487600224 45.34561097926819, 124.49948995964911 45.34560943855203, 124.49949183276983 45.34560759536879, 124.4994931434211 45.345605524666155, 124.49949383830923 45.34560331064323, 124.49949388917865 45.34560104332681, 124.49949329396098 45.34559881491074, 124.49949207685914 45.345596716007016, 124.49949028736295 45.34559483196144, 124.4994879982373 45.34559323938322, 124.49948530256256 45.34559200302988, 124.49948230995065 45.34559117317409, 124.49947914208727 45.345590783559494, 124.49940051626479 45.34558680250513, 124.49936596875159 45.345583896650616, 124.49936691347204 45.345579503695035, 124.49936971413689 45.34557926590146, 124.49942954159167 45.34558055252131, 124.4994741784122 45.345584171709525, 124.49947732090996 45.3455842066712, 124.49948041210102 45.34558380634395, 124.49948333191753 45.34558298627727, 124.49948596694801 45.34558177832417, 124.49948821484274 45.34558022940388, 124.49948998828928 45.345578399679496, 124.49949121840335 45.3455763602211, 124.49949185740526 45.34557419024519, 124.4994918804747 45.345571974037874, 124.49949128671591 45.3455697976809, 124.49949009919163 45.345567745708195, 124.49948836402767 45.34556589782233, 124.49948614862112 45.34556432579874, 124.49948353902263 45.34556309069785, 124.49948063659411 45.34556224049334, 124.49946663659652 45.34555924049386, 124.49946248609695 45.3455587599087, 124.49943185336595 45.345558101148605, 124.4993860982507 45.34555439126878, 124.4994807962953 45.34555524439731, 124.49948400663885 45.345555043636466, 124.49948709417345 45.3455543917883, 124.49948993278612 45.345553315478135, 124.4994924065309 45.345551858668834, 124.49949441436556 45.34555008086514, 124.49949587427842 45.345548054683015, 124.49949672663789 45.34554586288372, 124.49949693662882 45.34554359499329, 124.49949649567391 45.34554134364571, 124.4994954217844 45.345539200799315, 124.49949375882456 45.34553725398051, 124.49949157471922 45.34553558270888, 124.49948895868023 45.34553425524896, 124.49948601756209 45.34553332582199, 124.49948287149722 45.34553283239127, 124.49937478950261 45.345523825653764, 124.49937350516737 45.34551968264735, 124.49951479813375 45.345527213332005, 124.49951791132821 45.34552716425158, 124.49952095164272 45.34552668947184, 124.4995238031482 45.34552580709641, 124.49952635711507 45.34552455077078, 124.49952851615917 45.345522968399365, 124.49953019795494 45.34552112031892, 124.49953133837458 45.345519076997824, 124.4995318939333 45.34551691634905, 124.49953184344749 45.34551472075936, 124.49953118884201 45.34551257394785, 124.49952995507762 45.34551055777363, 124.49952818919853 45.345508749114536, 124.49952595853856 45.34550721693574, 124.49952334815411 45.345506019660064, 124.49952045758054 45.34550520294026, 124.49951739703714 45.34550479791834, 124.49938873107794 45.34549681863389, 124.49936576206179 45.34549470493523, 124.49936562088861 45.34549424953868, 124.49953104811715 45.34550122526357, 124.49953412944866 45.34550114460565, 124.49953713116678 45.34550064728584, 124.49953994104655 45.34549975189735, 124.49954245403546 45.345498491915976, 124.49954457618077 45.34549691444848, 124.4995462281419 45.34549507847144, 124.49954734815755 45.3454930526263, 124.4995478943537 45.34549091265306, 124.49954784630991 45.34548873855856, 124.49954720582251 45.34548661162541, 124.49954599683724 45.345484611372925, 124.49954426455442 45.345482812584265, 124.49954207373867 45.34548128251042, 124.49953950629768 45.34548007835606, 124.49953665822002 45.3454792451407, 124.49953363598621 45.345478814015614, 124.49936873762908 45.3454668214075, 124.4993568155797 45.345465845341785, 124.49935501069021 45.345460023119074, 124.499462705521 45.34546620820476, 124.49946582679667 45.34546617128666, 124.49946887806857 45.34546570627927, 124.49947174241038 45.345464831001934, 124.49947431005917 45.3454635789957, 124.49947648262138 45.34546199823811, 124.49947817684318 45.34546014930456, 124.49947932780145 45.34545810304712, 124.49947989139065 45.3454559378794, 124.49947984601418 45.345453736771674, 124.49947919341066 45.34545158407149, 124.4994779585884 45.345449562271355, 124.49947618886641 45.3454477488476, 124.49947395206138 45.34544621329148, 124.49947133388858 45.34544501444626, 124.49946843467781 45.34544419825225, 124.49946536552821 45.345443795986355, 124.49943252619688 45.34544180572378, 124.49938486655398 45.34543823127441, 124.49938782947102 45.34543795522694, 124.49950637450982 45.34544123666139, 124.49950944590614 45.34544111225635, 124.49951242627198 45.345440574280744, 124.49951520468544 45.34543964275671, 124.49951767774077 45.34543835235329, 124.49951975339724 45.34543675109605, 124.49952135440387 45.34543489857985, 124.49952242117541 45.34543286375071, 124.4995229140092 45.345430722339934, 124.49952281456338 45.345428554045455, 124.49952212653898 45.345426439565806, 124.49952087554284 45.345424457596614, 124.49951910813375 45.345422681901816, 124.4995168900904 45.34542117856828, 124.49951430396274 45.34542000354635, 124.49951144599999 45.34541920056737, 124.49950842256837 45.34541879951619, 124.49950669843774 45.345418690624435, 124.49950688732247 45.345417971460854, 124.49950685611016 45.345415801492436, 124.49950623441828 45.34541367615628, 124.49950504539882 45.345411674599625, 124.49950333333075 45.34540987136018, 124.49950116197115 45.34540833359031, 124.49949861218124 45.34540711855637, 124.49949577891493 45.34540627150603, 124.49949276768248 45.345405823983334, 124.49940357523843 45.3453988096802, 124.49920357527758 45.345384809682436, 124.4992013780526 45.34538476323801, 124.49909237807414 45.34538776323714, 124.49908933966151 45.34538805492067, 124.49908643659175 45.34538875130408, 124.49908377620727 45.345389826638254, 124.49905977620904 45.345401826636305, 124.4990570561963 45.34540354882958, 124.49905496379573 45.34540566256025, 124.4990421400479 45.345422432071274, 124.4990415330856 45.34542297719852, 124.4990400998361 45.34542499291229, 124.49902334769585 45.34545596859108, 124.49903865695043 45.345400134776874, 124.49903894676147 45.345397947488024, 124.4990386279947 45.34539576220321, 124.49903771281515 45.345393662319665, 124.49903623614892 45.34539172797547, 124.49903425435049 45.34539003299117, 124.49903184305118 45.34538864205261, 124.49902909427385 45.34538760824234, 124.49902611292016 45.34538697101372, 124.49902301276796 45.34538675468534, 124.49901991212849 45.34538696751299, 124.49901692933169 45.345387601374505, 124.49901417821044 45.34538863207979, 124.49901176375587 45.345390020293934, 124.49900977811127 45.34539171303839, 124.49900829705481 45.34539364571279, 124.49900737710834 45.345395744560314, 124.49898982989777 45.345456184896044, 124.4989797999903 45.34546484708803, 124.49895172331634 45.345443376683995, 124.49894941179606 45.34544192208885, 124.49894674505208 45.34544081011597, 124.49894382373357 45.345440082733845, 124.49894075809829 45.34543976739563, 124.49893766385057 45.34543987600296, 124.49893465777487 45.345440404456724, 124.49893185332746 45.3454413328118, 124.4989293563551 45.34544262602988, 124.49892726109941 45.345444235301755, 124.49892564664061 45.34544609988967, 124.49892457391216 45.345448149419596, 124.49892408340156 45.345450306537295, 124.49892419362182 45.34545248982798, 124.49892490041321 45.34545461688893, 124.49892617709959 45.345456607439736, 124.49896999261793 45.34551031682567, 124.49896665024866 45.345518181217656, 124.49896481931378 45.345516738724854, 124.49896241050166 45.3455154458154, 124.49895969861439 45.345514497194294, 124.4989567813755 45.345513927045424, 124.49895376390896 45.34551375591426, 124.49895075495003 45.34551398996763, 124.49894786292766 45.34551462077129, 124.49894519205667 45.345515625594054, 124.49894283858298 45.34551696822678, 124.49894088731476 45.34551860028724, 124.49892704753432 45.34553270120435, 124.49892651797038 45.34553222257398, 124.49892406667645 45.345530749064906, 124.49892124547989 45.34552965297611, 124.49891816947977 45.345528979025886, 124.49891496417114 45.34552875471011, 124.49891176032428 45.34552898918044, 124.49890868864996 45.3455296728709, 124.49890587446643 45.34553077788828, 124.49890343258703 45.34553225915002, 124.49890146263567 45.3455340562235, 124.49890004498268 45.3455360957916, 124.49887904497344 45.34557609578901, 124.49887828044466 45.34557810758173, 124.49887805515635 45.345580184291606, 124.49887837683707 45.34558225467957, 124.49887923445185 45.34558424772344, 124.49888059858138 45.3455860950542, 124.49888242243073 45.34558773330136, 124.4988846434351 45.34558910626675, 124.49888718540538 45.34559016685244, 124.4988899354425 45.345590872085644, 124.49886119353395 45.34574251020416, 124.49886105461968 45.34574416181404, 124.49886186533232 45.34578388729024, 124.498488195289 45.34583889017307, 124.49848191662615 45.34581754275406, 124.49855782448977 45.34562736472271, 124.49883874185164 45.34527870830849, 124.49925061164197 45.3448028586101, 124.49925197090475 45.34480087343709, 124.49925275484395 45.344798739410066, 124.49925293333344 45.34479653853847, 124.49925249951379 45.34479435540059, 124.49925147005672 45.34479227389318, 124.49924988452359 45.344790374007374, 124.49924780384566 45.34478872875472, 124.49924530798228 45.3447874013613, 124.49924249284791 45.3447864428381, 124.49923946662669 45.34478589002061, 124.49923634561443 45.34478576415327, 124.49923324974989 45.344786070073106, 124.49923029800524 45.34478679602378, 124.49922760381448 45.34478791410744, 124.49922527071364 45.34478938135678, 124.49922338836258 45.34479114138627, 124.49881138828847 45.34526714133854, 124.49852913469765 45.34561744480617, 124.4985276494515 45.34561995326283, 124.49846785969847 45.345769749215464, 124.49845961473318 45.345741716302484, 124.4984586828964 45.345739612045485, 124.49845718680432 45.34573767641509, 124.49845518395091 45.34573598379649, 124.49845275130477 45.345734599236025, 124.49844998235112 45.345733575941566, 124.49844698349918 45.3457329532377, 124.49844386999311 45.34573275505463, 124.49844076148322 45.345732989008354, 124.49843777742774 45.34573364610821, 124.49843503250206 45.34573470110221, 124.49843263219209 45.345736113447565, 124.4984306687406 45.345737828868636, 124.49842921760168 45.3457397814428, 124.498428334542 45.345741896133745, 124.49842805349707 45.34574409167509, 124.49842838526737 45.34574628369341, 124.49844910597022 45.345816734235825), (124.49902367452823 45.34553302554139, 124.49902762988489 45.34553038863297, 124.49907964619173 45.34553123443854, 124.49902367452823 45.34553302554139), (124.49910725317562 45.34553168332928, 124.49913871563426 45.34553219490207, 124.49914301161752 45.345533422325815, 124.4991469700762 45.345534153838024, 124.49928141913487 45.34554632122608, 124.49926183246515 45.34554482885132, 124.49916995169619 45.345536839218965, 124.49915784123651 45.345535829889414, 124.49910725317562 45.34553168332928), (124.49934128586361 45.34552106264456, 124.49922653930913 45.34551184941891, 124.49934030958225 45.34551791335112, 124.49934128586361 45.34552106264456), (124.49932331835208 45.345463102895756, 124.49919783912944 45.34545282971696, 124.49919547839822 45.34545276069933, 124.49911722599494 45.345454566541584, 124.49912749499356 45.34544811855827, 124.49916703554845 45.345449227160245, 124.49932177184007 45.34545811413813, 124.49932331835208 45.345463102895756), (124.49906217318203 45.3454561038147, 124.49906548344524 45.345446379907415, 124.49908158481783 45.34544683135344, 124.49906743595005 45.34545571552585, 124.49906547842396 45.345455760698414, 124.49906249375358 45.34545602986265, 124.49906217318203 45.3454561038147), (124.4990335572743 45.34550020722187, 124.49903957933441 45.345500754682874, 124.4990332611988 45.34550075468216, 124.4990335572743 45.34550020722187), (124.4992545011547 45.34556685109958, 124.4992265404614 45.34557145223182, 124.49919912335257 45.34556885481302, 124.49910745291477 45.345561801452405, 124.49901479426634 45.3455558234878, 124.49909443467949 45.345553274979416, 124.49916610102412 45.34555916536333, 124.4992545011547 45.34556685109958), (124.49905381583052 45.345585482393304, 124.49905886972968 45.34558530059546, 124.49906593290575 45.34558626776004, 124.49905381583052 45.345585482393304), (124.49896204733827 45.34560385590718, 124.49902758607907 45.345613984607525, 124.49903023614493 45.34561423240792, 124.49903290767617 45.34561416456351, 124.4990661618593 45.3456113390625, 124.49916170704849 45.34562112846347, 124.49916256593659 45.3456211997536, 124.49932056466102 45.345631259673844, 124.49926525003943 45.34573385930942, 124.49909092319788 45.345861698976584, 124.49891252439608 45.34588787705756, 124.4986117911456 45.34591048119496, 124.49849800694247 45.34587224970613, 124.49849467236241 45.34586091216878, 124.49888125859387 45.345804008043345, 124.49888425183217 45.345803345122455, 124.49888700308729 45.34580228178361, 124.49888940586911 45.34580085918438, 124.49889136717572 45.34579913238787, 124.49889281109289 45.345797168231364, 124.49889368173251 45.34579504273949, 124.49889394539562 45.34579283818144, 124.49889296230906 45.34574466759979, 124.49891988042752 45.34560265113215, 124.49896204733827 45.34560385590718)))</textarea>
            <div class="coord-settings" style="margin-bottom:8px;font-size:12px;color:#333;">
                <label>WKT坐标系：
                    <select id="coordSysSelect" style="margin-left:6px;">
                        <option value="wgs84" selected>WGS84</option>
                        <option value="gcj02">GCJ-02（国测局）</option>
                        <option value="bd09">BD-09（百度）</option>
                        <option value="cgcs2000">CGCS2000</option>
                    </select>
                </label>
                <!-- 已移除“不进行绘制坐标转换”选项，统一使用WGS84绘制 -->
            </div>

            <div class="button-group">
                <button id="drawButton" disabled>绘制轮廓</button>
                <button id="clearButton" disabled>清空轮廓</button>
            </div>
            <!-- 显示开关：仅保留显示亩数 -->
            <div class="display-toggles" style="margin-top:8px;font-size:12px;color:#333;">
                <label><input type="checkbox" id="toggleLabelsCheckbox"> 显示亩数</label>
            </div>
        </div>

        <div class="tab-pane" id="tabSplit">
            <!-- MultiPolygon → 多个 Polygon 分割器 -->
            <div class="split-section">
                <div class="title">MultiPolygon → 多个 Polygon 分割器</div>
                <div class="desc">输入一个 MULTIPOLYGON WKT，分割为多行 POLYGON WKT。</div>
                <textarea id="multiInput"></textarea>
                <div class="split-actions">
                    <button id="splitMultiBtn">分割为多个 POLYGON</button>
                    <button id="copyPolysBtn">复制结果</button>
                </div>
                <textarea id="polyOutput" readonly></textarea>
            </div>
        </div>

        <div class="tab-pane" id="tabBatch">
            <!-- 批量POLYGON → MULTIPOLYGON 生成器 -->
            <div class="batch-section">
                <div class="title">批量POLYGON → MULTIPOLYGON 合并器</div>
                <div class="desc">每行一个 POLYGON WKT（或用分号分隔）。生成后可一键填充到上方并绘制。</div>
                <textarea id="batchInput"></textarea>
                <div class="batch-actions">
                    <button id="generateMultiBtn">生成 MULTIPOLYGON</button>
                    <button id="copyMultiBtn">复制结果</button>
                </div>
                <textarea id="multiOutput" readonly></textarea>
            </div>
        </div>
        <div class="tab-pane" id="tabTrack">
            <div class="tip">请粘贴轨迹文本（支持两种格式：1）每行一条：定位时间yyyyMMddHHmmss, 经度, 纬度；2）单行#分隔：经度,纬度,定位时间yyyyMMddHHmmss#经度,纬度,定位时间yyyyMMddHHmmss#…）。</div>
            <div class="coord-settings" style="margin-bottom:8px;font-size:12px;color:#333;">
                <label>轨迹坐标系：
                    <select id="trackCoordSysSelect" style="margin-left:6px;">
                        <option value="wgs84" selected>WGS84</option>
                        <option value="gcj02">GCJ-02（国测局）</option>
                        <option value="bd09">BD-09（百度）</option>
                        <option value="cgcs2000">CGCS2000</option>
                    </select>
                </label>
            </div>
            <textarea id="trackTextarea" style="width:100%;height:120px;margin-bottom:10px;padding:8px;border:1px solid #ddd;border-radius:4px;font-family:monospace;resize:vertical;box-sizing:border-box;">20250930125620,124.504461,45.342159,5.3,0
20250930125630,124.504449,45.342141,1.0,0
20250930125640,124.504459,45.342098,2.2,0
20250930125650,124.504503,45.342061,0.8,0
20250930130711,124.504509,45.342037,0.0,0
20250930130721,124.504532,45.342030,0.0,0
20250930130731,124.504532,45.342030,0.0,0
20250930130741,124.504344,45.342010,12.5,0
20250930130751,124.504155,45.341996,0.0,0
20250930130801,124.504155,45.341996,0.0,0
20250930130811,124.504155,45.341996,0.0,0
20250930130821,124.504155,45.341996,0.0,0
20250930130831,124.504155,45.341996,0.0,0
20250930130841,124.504155,45.341996,0.0,0
20250930130851,124.504155,45.341996,0.0,0
20250930130901,124.504155,45.341996,0.0,0
20250930130911,124.504155,45.341996,0.0,0
20250930130921,124.504155,45.341996,0.0,0
20250930130931,124.504155,45.341996,0.0,0
20250930130941,124.504155,45.341996,0.0,0
20250930130951,124.504075,45.341975,11.1,0
20250930131001,124.503665,45.341870,12.1,0
20250930131011,124.503287,45.341748,9.5,0
20250930131021,124.502906,45.341643,10.5,0
20250930131031,124.502588,45.341997,16.7,0
20250930131041,124.502381,45.342301,7.5,0
20250930131051,124.502120,45.342415,6.7,0
20250930131101,124.501898,45.342589,16.3,0
20250930131111,124.501417,45.342698,19.8,0
20250930131121,124.501102,45.342806,16.5,0
20250930131131,124.500656,45.343304,22.0,0
20250930131141,124.500362,45.343601,17.8,0
20250930131151,124.499969,45.344033,14.8,0
20250930131201,124.499654,45.344349,22.7,0
20250930131211,124.499237,45.344797,23.1,0
20250930131221,124.498825,45.345273,15.0,0
20250930131231,124.498543,45.345623,17.4,0
20250930131241,124.498450,45.345856,4.7,0
20250930131251,124.498572,45.345871,0.0,0
20250930131301,124.498878,45.345793,6.4,0
20250930131311,124.498881,45.345772,0.0,0
20250930131321,124.498881,45.345772,0.0,0
20250930131331,124.498881,45.345772,0.0,0
20250930131341,124.498881,45.345772,0.0,0
20250930131351,124.498881,45.345772,0.0,0
20250930131401,124.498881,45.345772,0.0,0
20250930131411,124.498881,45.345772,0.0,0
20250930131421,124.498881,45.345772,0.0,0
20250930131431,124.498877,45.345744,7.0,0
20250930131441,124.498870,45.345607,0.0,0
20250930131555,124.498870,45.345607,0.0,0
20250930131605,124.498870,45.345607,0.0,0
20250930131615,124.498870,45.345607,0.0,0
20250930131625,124.498906,45.345591,2.4,0
20250930131635,124.499011,45.345594,2.7,0
20250930131645,124.499119,45.345601,2.8,0
20250930131655,124.499223,45.345611,1.5,0
20250930131705,124.499280,45.345615,1.9,0
20250930131715,124.499409,45.345625,3.2,0
20250930131725,124.499431,45.345627,4.0,0
20250930131735,124.499164,45.345610,7.9,0
20250930131745,124.498920,45.345585,4.1,0
20250930131755,124.498959,45.345592,11.2,0
20250930131805,124.498902,45.345575,0.0,0
20250930131815,124.498902,45.345575,0.0,0
20250930131825,124.498894,45.345580,1.2,0
20250930131835,124.498915,45.345540,1.8,0
20250930131845,124.498901,45.345579,3.6,0
20250930131855,124.498954,45.345525,2.8,0
20250930131905,124.498929,45.345579,0.1,0
20250930131915,124.498929,45.345579,0.0,0
20250930131925,124.498982,45.345565,2.9,0
20250930131935,124.499106,45.345573,3.5,0
20250930131945,124.499197,45.345580,1.4,0
20250930131955,124.499292,45.345589,2.8,0
20250930132005,124.499399,45.345598,2.8,0
20250930132015,124.499478,45.345602,0.9,0
20250930132025,124.499301,45.345607,8.3,0
20250930132035,124.499060,45.345574,6.6,0
20250930132045,124.498921,45.345579,3.5,0
20250930132055,124.498957,45.345552,0.0,0
20250930132105,124.498957,45.345552,0.0,0
20250930132115,124.498957,45.345552,0.0,0
20250930132125,124.498970,45.345546,2.4,0
20250930132135,124.499095,45.345542,3.8,0
20250930132146,124.499137,45.345545,0.0,0
20250930132156,124.499137,45.345545,0.0,0
20250930132206,124.499137,45.345545,0.0,0
20250930132216,124.499156,45.345547,0.1,0
20250930132226,124.499168,45.345548,1.4,0
20250930132236,124.499260,45.345556,2.9,0
20250930132246,124.499365,45.345564,3.0,0
20250930132256,124.499476,45.345573,3.1,0
20250930132306,124.499532,45.345577,0.0,0
20250930132316,124.499509,45.345576,0.0,0
20250930132326,124.499509,45.345576,0.0,0
20250930132336,124.499462,45.345570,2.5,0
20250930132346,124.499369,45.345568,2.9,0
20250930132356,124.499263,45.345577,2.8,0
20250930132406,124.499184,45.345590,1.7,0
20250930132416,124.499031,45.345603,6.3,0
20250930132426,124.498921,45.345586,6.7,0
20250930132436,124.498935,45.345563,0.0,0
20250930132446,124.498935,45.345563,0.0,0
20250930143758,124.498991,45.345520,0.0,0
20250930143808,124.499032,45.345512,2.5,0
20250930143818,124.499066,45.345512,2.1,0
20250930143828,124.499064,45.345513,4.0,0
20250930143838,124.499086,45.345513,0.0,0
20250930143848,124.499117,45.345514,0.7,0
20250930143858,124.499212,45.345522,3.9,0
20250930143908,124.499349,45.345533,3.7,0
20250930143918,124.499481,45.345544,3.6,0
20250930143928,124.499370,45.345543,7.5,0
20250930143938,124.499149,45.345523,5.7,0
20250930143948,124.499135,45.345521,0.0,0
20250930143958,124.499142,45.345521,3.0,0
20250930144008,124.499064,45.345513,0.0,0
20250930144018,124.499019,45.345519,2.2,0
20250930144028,124.498977,45.345533,4.5,0
20250930144038,124.498994,45.345493,0.7,0
20250930144048,124.498997,45.345486,0.0,0
20250930144058,124.498997,45.345486,0.0,0
20250930144108,124.499005,45.345460,3.6,0
20250930144118,124.499023,45.345398,3.4,0
20250930144128,124.499006,45.345460,2.8,0
20250930144138,124.498984,45.345479,2.4,0
20250930144148,124.498991,45.345490,4.0,0
20250930144158,124.498940,45.345451,1.5,0
20250930144208,124.499002,45.345527,3.4,0
20250930144218,124.499055,45.345429,4.4,0
20250930144228,124.499039,45.345476,3.4,0
20250930144238,124.499084,45.345486,3.2,0
20250930144248,124.499224,45.345493,5.3,0
20250930144258,124.499387,45.345508,4.2,0
20250930144308,124.499516,45.345516,8.0,0
20250930144318,124.499122,45.345495,8.1,0
20250930144328,124.499079,45.345493,4.9,0
20250930144338,124.499035,45.345489,2.9,0
20250930144349,124.499066,45.345467,1.7,0
20250930144359,124.499196,45.345464,4.5,0
20250930144409,124.499367,45.345478,5.1,0
20250930144419,124.499532,45.345490,1.4,0
20250930144429,124.499200,45.345476,7.4,0
20250930144439,124.499040,45.345488,2.5,0
20250930144449,124.499078,45.345444,0.0,0
20250930144459,124.499126,45.345434,3.4,0
20250930144509,124.499271,45.345441,4.6,0
20250930144519,124.499431,45.345453,4.7,0
20250930144529,124.499464,45.345455,11.7,0
20250930144539,124.499168,45.345438,6.0,0
20250930144549,124.499061,45.345435,3.7,0
20250930144559,124.499111,45.345410,3.2,0
20250930144609,124.499235,45.345411,4.8,0
20250930144619,124.499412,45.345424,5.6,0
20250930144629,124.499507,45.345430,7.8,0
20250930144639,124.499218,45.345422,5.3,0
20250930144649,124.499056,45.345428,2.9,0
20250930144659,124.499069,45.345411,1.8,0
20250930144709,124.499093,45.345399,5.5,0
20250930144719,124.499202,45.345396,3.7,0
20250930144729,124.499402,45.345410,6.4,0
20250930144739,124.499491,45.345417,7.8,0
20250930144749,124.499330,45.345432,5.9,0
20250930144759,124.499361,45.345532,1.6,0
20250930144809,124.499341,45.345625,5.3,0
20250930144819,124.499279,45.345740,5.5,0
20250930144829,124.499099,45.345872,6.5,0
20250930144839,124.498980,45.345921,0.0,0
20250930145119,124.498970,45.345908,0.0,0
20250930145129,124.498967,45.345906,0.0,0
20250930145139,124.498965,45.345906,0.0,0
20250930145149,124.498915,45.345899,4.7,0
20250930145159,124.498609,45.345922,8.6,0
20250930145209,124.498546,45.345900,0.0,0
20250930145219,124.498484,45.345880,6.1,0
20250930145229,124.498416,45.345836,0.0,0
20250930145239,124.498444,45.345744,11.2,0
20250930145249,124.498735,45.345392,20.8,0
20250930145259,124.499128,45.344941,28.8,0
20250930145309,124.499532,45.344476,4.4,0
20250930145319,124.499820,45.344178,23.7,0
20250930145329,124.500166,45.343821,10.3,0
20250930145339,124.500391,45.343557,18.7,0
20250930145349,124.500837,45.343101,22.0,0
20250930145359,124.501129,45.342775,9.5,0
20250930145409,124.501415,45.342702,12.8,0
20250930145419,124.501836,45.342651,16.1,0
20250930145429,124.502118,45.342423,5.5,0
20250930145439,124.502344,45.342354,5.8,0
20250930145449,124.502545,45.342073,20.7,0
20250930145459,124.502815,45.341705,10.2,0
20250930145509,124.503013,45.341655,9.5,0
20250930145519,124.503502,45.341822,21.1,0
20250930145529,124.504184,45.341975,19.3,0
20250930145539,124.504547,45.341988,4.5,0
20250930145549,124.504500,45.342051,3.8,0
20250930145559,124.504448,45.342116,1.7,0
20250930145609,124.504460,45.342167,3.0,0
20250930145619,124.504525,45.342199,0.0,0</textarea>
            <div class="button-group">
                <button id="drawTrackButton" disabled style="flex: 1;">绘制轨迹</button>
                <button id="showTrackPointsButton" disabled style="flex: 1;" class="btn-warning">打点</button>
                <button id="clearTrackButton" disabled style="flex: 1;">清空轨迹</button>
            </div>
            <!-- 回放控制 -->
            <div class="split-section" style="margin-top:8px;">
                <div class="title">轨迹回放</div>
                <div class="playback-actions" style="display:flex;gap:8px;margin-bottom:8px;">
                    <button id="playbackStartBtn" disabled>开始</button>
                    <button id="playbackPauseBtn" disabled>继续</button>
                    <button id="playbackStopBtn" disabled>结束</button>
                </div>
                <div class="playback-speed" style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <label>速度：
                        <select id="playbackSpeedSelect" disabled>
                            <option value="1" selected>1×</option>
                            <option value="2">2×</option>
                            <option value="4">4×</option>
                            <option value="8">8×</option>
                            <option value="16">16×</option>
                            <option value="32">32×</option>
                            <option value="64">64×</option>
                            <option value="128">128×</option>
                            <option value="256">256×</option>
                            <option value="512">512×</option>
                            <option value="1024">1024×</option>
                        </select>
                    </label>
                    <span id="playbackTimeLabel" style="font-size:12px;color:#666;">时间：—</span>
                </div>
                <div class="playback-time" style="display:flex;flex-direction:column;gap:4px;margin-bottom:8px;">
                    <label class="playback-time-label" style="display:flex;align-items:center;gap:8px;flex:1 1 auto;min-width:0;">
                        <span class="playback-time-text" style="white-space:nowrap;">起始时间：</span>
                        <input type="range" id="playbackTimeSlider" disabled min="0" max="0" step="1000" value="0" style="flex:1 1 auto;min-width:0;max-width:100%;vertical-align:middle;">
                    </label>
                    <span id="playbackTimeCursor" style="font-size:12px;color:#666;align-self:flex-end;">—</span>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let map;
    let currentPolygons = []; // 存储多边形和其标签
    let currentTracks = []; // 存储轨迹折线及相关覆盖物
    let mapLoaded = false;
    let mapLabelHandlers = []; // 存储地图事件处理器
    let labelsEnabled = false; // 标签显示开关（默认关闭）
    let isDrawing = false; // 绘制进行中防止重复点击

    window.onload = function () {
        if (typeof T === 'undefined') {
            alert("天地图API加载失败，请检查网络或密钥！");
            return;
        }
        initMap();
        bindDrawEvent();
        bindMinimizeEvent();
        bindTabs();
        bindBatchGenerator();
        bindMultiSplitter();
        bindLabelsToggle(); // 绑定标签显示开关
        bindTrackEvents();  // 绑定轨迹绘制与清空
        bindPlaybackControls(); // 绑定轨迹回放
    };

    function initMap() {
        showLoading();
        disableButtons(true);

        try {
            map = new T.Map("mapContainer", {
                zoom: 12,
                center: new T.LngLat(116.40769, 39.90403)
            });

            // 已移除测试标签
            map.enableScrollWheelZoom();

            // 添加地图类型控件
            const mapTypeCtrl = new T.Control.MapType({
                mapTypes: [TMAP_NORMAL_MAP, TMAP_SATELLITE_MAP, TMAP_TERRAIN_MAP],
                position: T_ANCHOR_TOP_LEFT
            });
            map.addControl(mapTypeCtrl);

            // 加载影像底图（卫星）
            const tk = "648f621977051d0199ff0f965d3fd322";

            // 方案1：使用默认地图类型（作为备选）
            map.setMapType(TMAP_SATELLITE_MAP);

            // 方案2：手动添加影像图层（底图 + 标注）
            const vecLayer = new T.TileLayer(`https://t0.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=${tk}`);
            const cvaLayer = new T.TileLayer(`https://t0.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&tk=${tk}`);

            // 添加图层并监听加载状态
            vecLayer.addEventListener("load", function () {
                console.log("影像底图加载完成");
            });

            vecLayer.addEventListener("error", function (e) {
                console.error("影像底图加载错误:", e);
                alert("影像底图加载错误，将使用默认地图类型");
            });

            map.addLayer(vecLayer);
            map.addLayer(cvaLayer);

            // 监听地图加载事件
            map.addEventListener("loaded", function () {
                console.log("地图加载完成");
                markMapLoaded();
            });
            map.addEventListener("load", function () {
                console.log("地图load事件触发");
                markMapLoaded();
            });
            map.addEventListener("tilesloaded", function () {
                console.log("地图瓦片加载完成");
                markMapLoaded();
            });
            // 监听地图加载失败事件
            map.addEventListener("error", function (e) {
                console.error("地图加载错误:", e);
                alert("地图加载错误: " + e.message);
                hideLoading();
            });

            // 监听地图移动事件，用于更新标签位置
            const moveHandler = function () {
                updateAllLabelsPosition();
            };
            map.addEventListener("move", moveHandler);
            map.addEventListener("zoom", moveHandler);

            // 存储事件处理器，用于清理
            mapLabelHandlers.push({ event: "move", handler: moveHandler });
            mapLabelHandlers.push({ event: "zoom", handler: moveHandler });

            // 超时容错
            setTimeout(() => {
                if (!mapLoaded) markMapLoaded();
            }, 8000);

        } catch (error) {
            alert("地图初始化失败：" + error.message);
            console.error(error);
            hideLoading();
        }
    }

    function markMapLoaded() {
        if (!mapLoaded) {
            mapLoaded = true;
            hideLoading();
            disableButtons(false);
            disableTrackButtons(false);
            // 仅开启速度选择，回放按钮按状态控制
            const speedSel = document.getElementById('playbackSpeedSelect');
            if (speedSel) speedSel.disabled = false;
            updatePlaybackButtonsState('idle');
        }
    }

    function showLoading() {
        const loading = document.getElementById("mapLoading");
        loading.style.display = "flex";
        loading.style.opacity = "1";
    }

    function hideLoading() {
        const loading = document.getElementById("mapLoading");
        loading.style.opacity = "0";
        setTimeout(() => loading.style.display = "none", 300);
    }

    function disableButtons(disabled) {
        document.getElementById("drawButton").disabled = disabled;
        document.getElementById("clearButton").disabled = disabled;
    }

    function disableTrackButtons(disabled) {
        const drawTrackBtn = document.getElementById("drawTrackButton");
        const showTrackPointsBtn = document.getElementById("showTrackPointsButton");
        const clearTrackBtn = document.getElementById("clearTrackButton");
        if (drawTrackBtn) drawTrackBtn.disabled = disabled;
        if (showTrackPointsBtn) showTrackPointsBtn.disabled = disabled;
        if (clearTrackBtn) clearTrackBtn.disabled = disabled;
    }
    // 回放控件的禁用/启用
    function disablePlaybackButtons(disabled) {
        ["playbackStartBtn","playbackPauseBtn","playbackStopBtn","playbackSpeedSelect","playbackTimeSlider"].forEach(id=>{
            const el = document.getElementById(id);
            if (el) el.disabled = disabled;
        });
    }

    // 回放按钮状态管理：空闲/播放/暂停
    function updatePlaybackButtonsState(state){
        try {
            const startBtn = document.getElementById('playbackStartBtn');
            const pauseBtn = document.getElementById('playbackPauseBtn');
            const stopBtn = document.getElementById('playbackStopBtn');
            if (!startBtn || !pauseBtn || !stopBtn) return;
            if (state === 'idle') {
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
                pauseBtn.textContent = '继续';
            } else if (state === 'playing') {
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
                pauseBtn.textContent = '暂停';
            } else if (state === 'paused') {
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
                pauseBtn.textContent = '继续';
            }
        } catch(e) { console.warn('更新按钮状态失败:', e); }
    }

    function bindDrawEvent() {
        document.getElementById("drawButton").addEventListener("click", function () {
            if (isDrawing) { console.log('绘制进行中，忽略重复点击'); return; }
            isDrawing = true;
            disableButtons(true);
            showLoading();
            try {
                const wktStr = document.getElementById("wktTextarea").value.trim();
                if (!wktStr) { alert("请输入WKT字符串！"); return; }
                clearOverlays();
                const geojson = parseWkt(wktStr);
    
                const polygonData = [];
                if (geojson.type === "Polygon") {
                    polygonData.push({ index: 1, coordinates: geojson.coordinates });
                } else if (geojson.type === "MultiPolygon") {
                    geojson.coordinates.forEach((polygon, index) => {
                        polygonData.push({ index: index + 1, coordinates: polygon });
                    });
                }
    
                // 重置并绘制
                polygonInfoList = [];
                polygonData.forEach(pd => processPolygon(pd.index, pd.coordinates));
    
                // 视图居中到所有已绘制轮廓
                try { fitViewportToPolygons(); } catch (e) { console.warn('视图居中失败', e); }
    
                // 在视图稳定后再创建/更新标签
                setTimeout(() => {
                    if (labelsEnabled) {
                        try {
                            createAllLabels();
                            updateAllLabelsPosition();
                        } catch (e) {
                            console.warn('创建或更新标签失败:', e);
                        }
                    }
                }, 150);
            } catch (e) {
                alert('绘制失败：' + (e && e.message ? e.message : e));
                console.error('绘制异常:', e);
            } finally {
                hideLoading();
                isDrawing = false;
                disableButtons(false);
            }
        });

        document.getElementById("clearButton").addEventListener("click", function () {
            if (isDrawing) { console.log('绘制进行中，暂不清空'); return; }
            clearOverlays();
            console.log("已清空所有轮廓");
        });
    }

    // 存储多边形数据，用于后续标签创建
    let polygonInfoList = [];

    // 处理单个多边形的绘制和面积计算
    function processPolygon(actualPolygonIndex, polygonCoords) {
        console.log('开始处理多边形', actualPolygonIndex);

        // 坐标系选择（绘制始终使用WGS84坐标）
        const coordSys = (document.getElementById('coordSysSelect') && document.getElementById('coordSysSelect').value) || 'wgs84';

        // 统一转换为WGS84用于绘制与面积计算
        function toWgs(point){
            const lng = point[0], lat = point[1];
            if (coordSys === 'wgs84' || coordSys === 'cgcs2000') {
                return [lng, lat];
            } else if (coordSys === 'gcj02') {
                const w = gcj02ToWgs84(lng, lat);
                return [w.lng, w.lat];
            } else if (coordSys === 'bd09') {
                const gcj = bd09ToGcj02(lng, lat);
                const w = gcj02ToWgs84(gcj.lng, gcj.lat);
                return [w.lng, w.lat];
            }
            return [lng, lat];
        }
        const coordsWGS84 = polygonCoords.map(ring => ring.map(toWgs));
        let outerRingWGS = coordsWGS84[0] || [];

        // 生成用于绘制的坐标（直接使用WGS84坐标）
        const rings = coordsWGS84.map(ring => ring.map(([lng, lat]) => new T.LngLat(lng, lat)));


         // 创建半透明填充的多边形（无边框）
          const polygon = new T.Polygon(rings, {
              color: "#FFD700",
              weight: 1,
              opacity: 1,
              fillColor: "#FFFF00",
              fillOpacity: 0.35
          });
 
          // 使用WGS84坐标计算面积（更准确的面积计算）
         let areaSqm;
         let areaMu;



         try {
             // 检查Turf.js是否可用
             if (typeof turf !== 'undefined' && turf.area) {
                 // 使用Turf.js计算多边形面积
                // 构造GeoJSON格式的多边形
                const geoJsonPolygon = {
                    type: "Polygon",
                    coordinates: coordsWGS84
                };


                 // 使用Turf.js计算面积（平方米）
                 areaSqm = turf.area(geoJsonPolygon);
                 areaMu = (areaSqm / 666.6667).toFixed(4); // 转换为亩
                 console.log(`多边形${actualPolygonIndex}面积计算结果(Turf.js): ${areaSqm}平方米 = ${areaMu}亩`);
             } else {
                 // 如果Turf.js不可用，回退到之前的计算方法
                 console.warn('Turf.js不可用，使用备用计算方法');
                 // 计算带孔洞的多边形面积
                 areaSqm = 0;
                 // 计算外环面积
                 outerRingWGS = coordsWGS84[0] || [];
                 areaSqm += calculatePolygonArea(outerRingWGS);

                 // 减去内环（孔洞）面积
                 for (let i = 1; i < coordsWGS84.length; i++) {
                     const innerRingArea = calculatePolygonArea(coordsWGS84[i]);
                     areaSqm -= innerRingArea;
                 }

                  areaMu = (areaSqm / 666.6667).toFixed(4); // 使用更精确的转换系数
                  console.log(`多边形${actualPolygonIndex}面积计算结果(备用): ${areaSqm}平方米 = ${areaMu}亩`);
              }
          } catch (error) {
              console.error(`面积计算失败:`, error);
              areaSqm = 0;
              areaMu = '0.0000';
          }

          // 计算多边形的中心点和底部中心点（WGS84）
          const centerPoint = calculatePolygonCenter(outerRingWGS);
          const bottomCenterPoint = calculatePolygonBottomCenter(outerRingWGS);

          // 添加多边形到地图
          if (map) {
              map.addOverLay(polygon);
              console.log(`多边形${actualPolygonIndex}已添加到地图`);
          } else {
              console.error('地图对象不存在');
          }

          // 存储多边形信息，用于后续标签创建
          polygonInfoList.push({
              index: actualPolygonIndex,
              polygon: polygon,
              area: areaMu,
              bottomCenter: { lng: bottomCenterPoint.lng, lat: bottomCenterPoint.lat },
              ringPoints: rings
          });
      }

    // 视图居中：根据已绘制的GCJ-02点
    function fitViewportToPolygons() {
        const points = [];
        try {
            if (!map || !map.setViewport) return;
            polygonInfoList.forEach(info => {
                if (!info || !info.ringPoints) return;
                info.ringPoints.forEach(ring => {
                    ring.forEach(ll => points.push(ll));
                });
            });
            if (!points.length) return;
            map.setViewport(points);
        } catch (e) {
            try {
                const lngs = points.map(p => p.lng);
                const lats = points.map(p => p.lat);
                const center = new T.LngLat(
                    (Math.min(...lngs) + Math.max(...lngs)) / 2,
                    (Math.min(...lats) + Math.max(...lats)) / 2
                );
                if (map && map.panTo) map.panTo(center);
            } catch (e2) {
                console.warn('视图居中失败:', e2);
            }
        }
    }

    // 统一创建所有多边形的标签
    function createAllLabels() {
        const mapContainer = document.getElementById('mapContainer');
        if (!mapContainer || !map) return;

        polygonInfoList.forEach(info => {
            if (!info) return;
            // 防止重复创建
            if (info.labelRef) return;
            // 创建标签元素
            const labelDiv = document.createElement('div');
            labelDiv.className = 'area-label';
            labelDiv.innerHTML = `多边形${info.index}：${info.area}亩`;

            // 添加到地图容器并根据屏幕边界定位到轮廓下方
            mapContainer.appendChild(labelDiv);
            positionLabelForPolygon(labelDiv, info);

            // 记录引用，避免重复创建
            info.labelRef = labelDiv;

            // 存储到 currentPolygons 以复用现有定位/清理逻辑
            const labelObj = {
                domElement: labelDiv,
                isDomLabel: true,
                polygonInfo: info
            };
            currentPolygons.push({ polygon: info.polygon, label: labelObj });
        });

        // 不清空 polygonInfoList，便于开关随时创建/隐藏标签
    }

    // 根据多边形屏幕边界定位标签，保证始终在轮廓下方
    function positionLabelForPolygon(labelDiv, info) {
        if (!map || !info || !info.ringPoints) return;
        const points = [];
        info.ringPoints.forEach(ring => {
            ring.forEach(ll => {
                const p = map.lngLatToContainerPoint(ll);
                points.push(p);
            });
        });
        if (!points.length) return;
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const maxY = Math.max(...points.map(p => p.y));
        const container = document.getElementById('mapContainer');
        const labelWidth = labelDiv.offsetWidth;
        const labelHeight = labelDiv.offsetHeight;
        const targetLeft = Math.round((minX + maxX) / 2 - labelWidth / 2);
        const targetTop = Math.round(maxY + 6);
        const clampedLeft = Math.max(0, Math.min(targetLeft, container.clientWidth - labelWidth));
        const clampedTop = Math.max(0, Math.min(targetTop, container.clientHeight - labelHeight));
        labelDiv.style.left = clampedLeft + 'px';
        labelDiv.style.top = clampedTop + 'px';
    }

    // 更新所有标签位置（地图move/zoom时调用）
    function updateAllLabelsPosition() {
        try {
            if (!map) return;
            const container = document.getElementById('mapContainer');
            if (!container) return;
            currentPolygons.forEach(item => {
                if (!item || !item.label) return;
                const labelObj = item.label;
                if (labelObj.isDomLabel && labelObj.domElement && labelObj.polygonInfo) {
                    // 确保标签在容器中
                    if (!labelObj.domElement.parentNode) {
                        container.appendChild(labelObj.domElement);
                    }
                    positionLabelForPolygon(labelObj.domElement, labelObj.polygonInfo);
                }
            });
        } catch (e) {
            console.warn('更新标签位置时出错:', e);
        }
    }
    // 确保在全局可用（处理第三方库事件回调作用域差异）
    window.updateAllLabelsPosition = updateAllLabelsPosition;

    // 绑定“显示亩数标签”开关（默认隐藏）
    function bindLabelsToggle() {
        const cb = document.getElementById('toggleLabelsCheckbox');
        const container = document.getElementById('mapContainer');
        if (!cb || !container) return;
        // 默认隐藏标签
        container.classList.add('labels-hidden');
        cb.addEventListener('change', () => {
            labelsEnabled = cb.checked;
            if (labelsEnabled) {
                container.classList.remove('labels-hidden');
                const hasAnyLabel = currentPolygons.some(item => item && item.label && item.label.domElement);
                if (!hasAnyLabel) {
                    try { createAllLabels(); } catch (e) { console.warn('创建标签失败:', e); }
                }
                updateAllLabelsPosition();
            } else {
                container.classList.add('labels-hidden');
            }
        });
    }

    /**
     * 计算多边形中心点（比底部中心更适合显示标签）
     */
    function calculatePolygonCenter(outerRing) {
        let sumLng = 0, sumLat = 0;
        const len = outerRing.length;

        for (let i = 0; i < len; i++) {
            sumLng += outerRing[i][0];
            sumLat += outerRing[i][1];
        }

        return {
            lng: sumLng / len,
            lat: sumLat / len
        };
    }

    /**
     * 计算多边形面积（球面多边形面积计算）
     * 使用更准确的球面坐标面积计算方法，确保面积与视觉大小一致
     */
    function calculatePolygonArea(coordinates) {
        // 地球半径（米）- 使用更精确的值
        const R = 6371000.8;
        const n = coordinates.length;

        // 将所有坐标转换为弧度
        const coordsRad = coordinates.map(point => [
            point[0] * Math.PI / 180,
            point[1] * Math.PI / 180
        ]);

        let areaRad = 0;

        // 使用更准确的球面多边形面积公式（Girard定理）
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            const lon1 = coordsRad[i][0];
            const lat1 = coordsRad[i][1];
            const lon2 = coordsRad[j][0];
            const lat2 = coordsRad[j][1];

            // 计算球面多边形面积增量
            const dlon = lon2 - lon1;
            const sinLat1 = Math.sin(lat1);
            const sinLat2 = Math.sin(lat2);
            const cosLat1 = Math.cos(lat1);
            const cosLat2 = Math.cos(lat2);

            // 使用更精确的公式
            areaRad += dlon * (sinLat1 * cosLat2 * Math.cos(dlon / 2) + sinLat2 * cosLat1);
        }

        // 计算总面积（平方米）
        const areaSqm = Math.abs(areaRad) * R * R * 0.5;

        return areaSqm;
    }

    /**
     * 清空所有多边形和标签（同时处理 polygonInfoList 与 currentPolygons）
     */
    function clearOverlays() {
        try {
            // 先移除 polygonInfoList 中记录的多边形与其DOM标签
            polygonInfoList.forEach(info => {
                if (info && info.polygon && map && map.removeOverLay) {
                    try { map.removeOverLay(info.polygon); } catch (e) { console.warn('移除多边形失败:', e); }
                }
                if (info && info.labelRef && info.labelRef.parentNode) {
                    try { info.labelRef.parentNode.removeChild(info.labelRef); } catch (e) { console.warn('移除DOM标签失败:', e); }
                    info.labelRef = null;
                }
            });

            // 再处理 currentPolygons（兼容旧路径与标签对象）
            currentPolygons.forEach(item => {
                if (item.polygon && map && map.removeOverLay) {
                    try { map.removeOverLay(item.polygon); } catch (e) { console.warn('移除多边形失败:', e); }
                }
                if (item.label) {
                    if (item.label.domElement && item.label.domElement.parentNode) {
                        try { item.label.domElement.parentNode.removeChild(item.label.domElement); } catch (e) { console.warn('移除DOM标签失败:', e); }
                    } else if (map && map.removeOverLay && !item.label.isDomLabel) {
                        try { map.removeOverLay(item.label); } catch (e) { console.warn('移除地图覆盖物标签失败:', e); }
                    }
                }
            });

            // 清空记录数组
            currentPolygons = [];
            polygonInfoList = [];

            console.log('已清空所有多边形和标签（保留事件监听器）');
        } catch (error) {
            console.error('清空覆盖物时出错:', error);
        }
    }

    // 其他辅助函数（保持不变）
    function bindMinimizeEvent() {
        const container = document.querySelector(".wkt-input-container");
        const btn = document.getElementById("minimizeBtn");
        const minIcon = btn?.querySelector(".min-icon");
        const restoreIcon = btn?.querySelector(".restore-icon");

        btn?.addEventListener("click", () => {
            const minimized = container.classList.toggle("minimized");
            if (minIcon && restoreIcon) {
                if (minimized) {
                    minIcon.style.display = "none";
                    restoreIcon.style.display = "";
                } else {
                    minIcon.style.display = "";
                    restoreIcon.style.display = "none";
                }
            }
        });
    }

    // 在脚本内部补充：页签切换（3个页签）
     function bindTabs() {
         const tabs = [
             { btn: document.getElementById('tabDrawBtn'), pane: document.getElementById('tabDraw'), key: 'draw' },
             { btn: document.getElementById('tabTrackBtn'), pane: document.getElementById('tabTrack'), key: 'track' },
             { btn: document.getElementById('tabSplitBtn'), pane: document.getElementById('tabSplit'), key: 'split' },
             { btn: document.getElementById('tabBatchBtn'), pane: document.getElementById('tabBatch'), key: 'batch' },
         ];
         if (tabs.some(t => !t.btn || !t.pane)) return;
         function activate(key) {
             tabs.forEach(t => {
                 const active = t.key === key;
                 t.btn.classList.toggle('active', active);
                 t.pane.classList.toggle('active', active);
             });
         }
         tabs.forEach(t => t.btn.addEventListener('click', () => activate(t.key)));
         activate('draw');
     }
    function updateParserStatus() {
        const el = document.getElementById('parserStatus');
        if (!el) return;
        const ok = (typeof Terraformer !== 'undefined' && Terraformer.WKT && typeof Terraformer.WKT.parse === 'function');
        if (ok) {
            el.textContent = 'Terraformer WKT Parser';
            el.style.color = '#2f8f2f';
        } else {
            el.textContent = '本地回退解析（仅支持POLYGON/MULTIPOLYGON）';
            el.style.color = '#c77d1e';
        }
    }
     function parseWkt(wkt) {
         wkt = wkt.trim();
         // 优先使用成熟库（Terraformer WKT Parser）
         if (typeof Terraformer !== 'undefined' && Terraformer.WKT && Terraformer.WKT.parse) {
             try {
                 return Terraformer.WKT.parse(wkt);
             } catch (e) {
                 console.warn('Terraformer解析失败，尝试本地回退解析:', e);
             }
         } else {
             // 不再提示“未加载”，由状态栏展示回退信息
         }
         // 回退解析：仅支持 POLYGON / MULTIPOLYGON
         const typeMatch = wkt.match(/^\s*(POLYGON|MULTIPOLYGON)\s*\(/i);
         if (!typeMatch) throw new Error('仅支持POLYGON/MULTIPOLYGON');
         const type = typeMatch[1].toUpperCase();
         const inner = wkt.substring(wkt.indexOf('('));
         if (type === 'POLYGON') {
             const coords = parsePolygonCoords(inner.replace(/^\(/, '').replace(/\)$/, ''));
             return { type: 'Polygon', coordinates: coords };
         } else {
             const trimmed = inner.replace(/^\(\(/, '').replace(/\)\)$/, '');
             const coords = parseMultiPolygonCoords(trimmed);
             return { type: 'MultiPolygon', coordinates: coords };
         }
     }

     function bindMultiSplitter() {
         const input = document.getElementById('multiInput');
         const output = document.getElementById('polyOutput');
         const splitBtn = document.getElementById('splitMultiBtn');
         const copyBtn = document.getElementById('copyPolysBtn');
         if (!input || !output || !splitBtn || !copyBtn) return;

         // 本地WKT序列化辅助
         function ringToText(ring) {
             if (!ring || !ring.length) return '()';
             const first = ring[0];
             const last = ring[ring.length - 1];
             const closed = (first[0] === last[0] && first[1] === last[1]) ? ring : ring.concat([[first[0], first[1]]]);
             return '(' + closed.map(pt => pt[0] + ' ' + pt[1]).join(', ') + ')';
         }
         function toWktPolygonCoords(coords) {
             return 'POLYGON(' + coords.map(ringToText).join(', ') + ')';
         }
         function toWktMulti(coords) {
             return 'MULTIPOLYGON(' + coords.map(poly => '(' + poly.map(ringToText).join(', ') + ')').join(', ') + ')';
         }

         function polygonsFromMulti(text) {
             const geo = parseWkt(text.trim());
             if (geo.type !== 'MultiPolygon') throw new Error('请输入有效的 MULTIPOLYGON WKT');
             const polys = geo.coordinates.map(rings => toWktPolygonCoords(rings));
             return polys;
         }
         splitBtn.addEventListener('click', () => {
             try {
                 const list = polygonsFromMulti(input.value.trim());
                 output.value = list.join('\n');
             } catch (e) {
                 alert('分割失败：' + e.message);
             }
         });
         copyBtn.addEventListener('click', async () => {
             const val = output.value.trim();
             if (!val) { alert('没有可复制的结果'); return; }
             try { await navigator.clipboard.writeText(val); alert('已复制到剪贴板'); } catch (e) { console.warn('复制失败', e); }
         });
     }

     function bindBatchGenerator() {
         const batchInput = document.getElementById('batchInput');
         const output = document.getElementById('multiOutput');
         const genBtn = document.getElementById('generateMultiBtn');
         const copyBtn = document.getElementById('copyMultiBtn');

         // 本地WKT序列化辅助（与分割器保持一致）
         function ringToText(ring) {
             if (!ring || !ring.length) return '()';
             const first = ring[0];
             const last = ring[ring.length - 1];
             const closed = (first[0] === last[0] && first[1] === last[1]) ? ring : ring.concat([[first[0], first[1]]]);
             return '(' + closed.map(pt => pt[0] + ' ' + pt[1]).join(', ') + ')';
         }
         function toWktMulti(coords) {
             return 'MULTIPOLYGON(' + coords.map(poly => '(' + poly.map(ringToText).join(', ') + ')').join(', ') + ')';
         }

         genBtn.addEventListener('click', () => {
             try {
                 const lines = batchInput.value.trim().split(/\n|;/).map(s => s.trim()).filter(Boolean);
                 if (lines.length === 0) throw new Error('请按每行或分号输入至少一个POLYGON');
                 const polygons = lines.map((line, idx) => {
                     const g = parseWkt(line);
                     if (g.type !== 'Polygon') throw new Error(`第${idx + 1}行不是有效的POLYGON WKT`);
                     return g;
                 });
                 const multiGeo = { type: 'MultiPolygon', coordinates: polygons.map(p => p.coordinates) };
                 output.value = toWktMulti(multiGeo.coordinates);
             } catch (e) {
                 alert('生成失败：' + e.message);
             }
         });

         copyBtn.addEventListener('click', async () => {
             const val = output.value.trim();
             if (!val) { alert('没有可复制的结果'); return; }
             try { await navigator.clipboard.writeText(val); alert('已复制到剪贴板'); } catch (e) { console.warn('复制失败', e); }
         });

     }

     function setExampleWkt() {
         const exampleWkt = "MULTIPOLYGON(" +
             "(" +
             "(116.35 39.93, 116.39 39.93, 116.39 39.90, 116.35 39.90, 116.35 39.93)," + // 外环
             "(116.36 39.92, 116.38 39.92, 116.38 39.91, 116.36 39.91, 116.36 39.92)" +  // 内环
             ")," +
             "(" +
             "(116.40 39.95, 116.43 39.97, 116.46 39.96, 116.49 39.98, 116.52 39.95, 116.55 39.93, 116.58 39.94, 116.61 39.92, 116.64 39.95, 116.40 39.95)" +
             ")" +
             ")";
         document.getElementById("wktTextarea").value = exampleWkt;
     }

     function parsePolygonCoords(coordStr) {
         const ringStrs = coordStr.split(/\)\s*,\s*\(/).map(s => s.replace(/[()]/g, '').trim());
         const rings = [];
         ringStrs.forEach(ringStr => {
             const pts = ringStr.split(/,\s*/).map(pointStr => {
                 const [lng, lat] = pointStr.split(/\s+/).map(Number);
                 if (isNaN(lng) || isNaN(lat)) throw new Error("坐标格式错误：" + pointStr);
                 return [lng, lat];
             });
             // 自动拆分：如果一个ring中包含多次回到起点（闭合），则拆分为多个环
             // 兼容用户将外环与内环错误地写在同一对括号中的情况
             let start = 0;
             while (start < pts.length) {
                 const startPt = pts[start];
                 let closeIdx = -1;
                 for (let i = start + 1; i < pts.length; i++) {
                     if (pts[i][0] === startPt[0] && pts[i][1] === startPt[1]) {
                         closeIdx = i;
                         break;
                     }
                 }
                 if (closeIdx === -1) {
                     // 未找到闭合：将剩余点视为一个环，并强制闭合
                     const ring = pts.slice(start);
                     if (ring.length && (ring[0][0] !== ring[ring.length - 1][0] || ring[0][1] !== ring[ring.length - 1][1])) {
                         ring.push([ring[0][0], ring[0][1]]);
                     }
                     rings.push(ring);
                     break;
                 } else {
                     const ring = pts.slice(start, closeIdx + 1);
                     rings.push(ring);
                     start = closeIdx + 1;
                 }
             }
         });
         return rings;
     }

     function parseMultiPolygonCoords(coordStr) {
         const polygonStrs = coordStr.split(/\)\s*\)\s*,\s*\(\s*\(/).map(s => s.replace(/[()]/g, '').trim());
         return polygonStrs.map(polygonStr => parsePolygonCoords(polygonStr));
     }

     function wgs84ToGcj02(lng, lat) {
         const x_PI = 3.14159265358979324 * 3000.0 / 180.0;
         const PI = 3.1415926535897932384626;
         const a = 6378245.0;
         const ee = 0.00669342162296594323;

         if (outOfChina(lng, lat)) return { lng, lat };

         let dlat = transformLat(lng - 105.0, lat - 35.0);
         let dlng = transformLng(lng - 105.0, lat - 35.0);
         const radlat = lat / 180.0 * PI;
         let magic = Math.sin(radlat);
         magic = 1 - ee * magic * magic;
         const sqrtmagic = Math.sqrt(magic);
         dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI);
         dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI);

         return { lng: lng + dlng, lat: lat + dlat };

         function outOfChina(lng, lat) {
             return (lng < 72.004 || lng > 137.8347) || (lat < 0.8293 || lat > 55.8271);
         }

         function transformLat(x, y) {
             let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
             ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
             ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0;
             ret += (160.0 * Math.sin(y / 12.0 * PI) + 320 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0;
             return ret;
         }

         function transformLng(x, y) {
             let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
             ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
             ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0;
             ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0;
             return ret;
         }
     }

     function gcj02ToWgs84(lng, lat) {
         const g = wgs84ToGcj02(lng, lat);
         return { lng: lng * 2 - g.lng, lat: lat * 2 - g.lat };
     }

     function bd09ToGcj02(bdLng, bdLat) {
         const x_PI = 3.14159265358979324 * 3000.0 / 180.0;
         const x = bdLng - 0.0065;
         const y = bdLat - 0.006;
         const z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_PI);
         const theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_PI);
         const ggLng = z * Math.cos(theta);
         const ggLat = z * Math.sin(theta);
         return { lng: ggLng, lat: ggLat };
     }

     function calculatePolygonBottomCenter(outerRing) {
         let minLat = Infinity;
         let bottomPoints = [];
         outerRing.forEach(point => {
             const lat = point[1];
             if (lat < minLat) {
                 minLat = lat;
                 bottomPoints = [point];
             } else if (lat === minLat) {
                 bottomPoints.push(point);
             }
         });

         const sumLng = bottomPoints.reduce((sum, point) => sum + point[0], 0);
         const centerLng = sumLng / bottomPoints.length;

         return { lng: centerLng, lat: minLat };
     }

     function fitBounds(geojson) {
         try {
             const allPoints = [];
             function collectPoints(coords) {
                 if (typeof coords[0] === 'number') {
                     allPoints.push(coords);
                 } else {
                     coords.forEach(coord => collectPoints(coord));
                 }
             }
             collectPoints(geojson.coordinates);

             if (allPoints.length === 0) return;

             const lats = allPoints.map(p => p[1]);
             const lngs = allPoints.map(p => p[0]);
             const minLng = Math.min(...lngs);
             const maxLng = Math.max(...lngs);
             const minLat = Math.min(...lats);
             const maxLat = Math.max(...lats);

             const sw = wgs84ToGcj02(minLng, minLat);
             const ne = wgs84ToGcj02(maxLng, maxLat);

             // 修复setViewport方法的使用，确保参数格式正确
             if (map && map.setViewport) {
                 map.setViewport([
                     new T.LngLat(sw.lng, sw.lat),
                     new T.LngLat(ne.lng, ne.lat)
                 ], { padding: [50, 50] });
             } else {
                 console.warn('地图对象或setViewport方法不可用');
             }
         } catch (error) {
             console.error('调整视图范围时出错:', error);
         }
     }
// 轨迹绘制与解析
    function bindTrackEvents() {
        const drawBtn = document.getElementById('drawTrackButton');
        const showPointsBtn = document.getElementById('showTrackPointsButton');
        const clearBtn = document.getElementById('clearTrackButton');
        const ta = document.getElementById('trackTextarea');
        if (!drawBtn || !showPointsBtn || !clearBtn || !ta) return;

        drawBtn.addEventListener('click', function(){
            try {
                const text = ta.value.trim();
                if (!text) { alert('请粘贴轨迹文本（时间戳,经度,纬度）'); return; }
                const points = parseTrackText(text);
                if (points.length < 2) { alert('有效轨迹点不足，至少需要两点'); return; }
                drawTrackFromPoints(points);
                fitViewportToTrack(points);
            } catch (e) {
                alert('绘制轨迹失败：' + (e && e.message ? e.message : e));
                console.error('绘制轨迹异常:', e);
            }
        });

        showPointsBtn.addEventListener('click', function(){
            try {
                const text = ta.value.trim();
                if (!text) { alert('请粘贴轨迹文本（时间戳,经度,纬度）'); return; }
                const points = parseTrackText(text);
                if (points.length === 0) { alert('未找到有效轨迹点'); return; }
                showTrackPoints(points);
                fitViewportToTrack(points);
            } catch (e) {
                alert('显示轨迹点失败：' + (e && e.message ? e.message : e));
                console.error('显示轨迹点异常:', e);
            }
        });

        clearBtn.addEventListener('click', function(){
            clearTrackOverlays();
            console.log('已清空轨迹');
        });
    }

    function showTrackPoints(points) {
        // 先移除旧轨迹（不影响轮廓）
        clearTrackOverlays(false);
        
        if (!map || !points || points.length === 0) {
            console.log('无轨迹点可显示');
            return;
        }
        
        console.log(`准备显示${points.length}个轨迹点`);
        
        // 使用批量处理和更小的图标来提高性能
        // 创建一个更小的红点SVG图标
        const smallRedDotIcon = new T.Icon({
            iconUrl: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"><circle cx="0.5" cy="0.5" r="0.3" fill="%23FF0000"/></svg>',
            iconSize: new T.Point(1, 1),
            iconAnchor: new T.Point(0.5, 0.5)
        });
        
        // 优化批量添加点的速度
        const batchSize = 2000; // 增加每批处理的点数
        const concurrentBatches = 4; // 并发批次数量
        
        // 预创建点击事件处理函数，避免重复创建
        function createClickHandler(point, index) {
            return function() {
                const infoWindow = new T.InfoWindow({
                    content: `点${index + 1}<br/>经度: ${point.lng.toFixed(6)}<br/>纬度: ${point.lat.toFixed(6)}`,
                    offset: new T.Point(0, -20)
                });
                infoWindow.open(map, point);
            };
        }
        
        // 使用setTimeout实现更高效的批量添加，避免阻塞UI
        let currentIndex = 0;
        
        function addBatch() {
            if (currentIndex >= points.length) {
                console.log(`已显示${points.length}个轨迹点`);
                return;
            }
            
            // 添加当前批次的点
            const endIndex = Math.min(currentIndex + batchSize, points.length);
            const markersToAdd = [];
            
            // 先创建所有标记
            for (let i = currentIndex; i < endIndex; i++) {
                const point = points[i];
                const index = i;
                
                const marker = new T.Marker(point, {
                    icon: smallRedDotIcon
                });
                
                // 添加点击事件
                marker.addEventListener('click', createClickHandler(point, index));
                
                markersToAdd.push(marker);
            }
            
            // 批量添加到地图和数组
            markersToAdd.forEach(marker => {
                map.addOverLay(marker);
                currentTracks.push(marker);
            });
            
            currentIndex = endIndex;
            
            // 使用setTimeout而不是requestAnimationFrame，减少对渲染周期的依赖
            // 设置为0，将任务放入微任务队列，但允许UI有短暂的呼吸空间
            setTimeout(addBatch, 0);
        }
        
        // 启动批量添加
        addBatch();
    }
    
    // 恢复原始的clearTrackOverlays函数
    function clearTrackOverlays(resetArray = true){        
        try {
            currentTracks.forEach(pl => {
                if (pl && map && map.removeOverLay) {
                    try { map.removeOverLay(pl); } catch (e) { console.warn('移除轨迹失败:', e); }
                }
            });
            if (resetArray) currentTracks = [];
        } catch (e) {
            console.warn('清空轨迹时出错:', e);
        }
    }

    function parseTrackText(text){
        // 选择输入坐标系（优先使用轨迹页签专属选择器，若未设置则回退到绘制页签选择器）
        const coordSysEl = document.getElementById('trackCoordSysSelect') || document.getElementById('coordSysSelect');
        const coordSys = (coordSysEl && coordSysEl.value) || 'wgs84';
        const isHash = text.indexOf('#') !== -1;
        const items = isHash ? text.split('#') : text.split(/\r?\n/);
        const pts = [];
        for (let i=0;i<items.length;i++){
            const raw = items[i];
            if (!raw) continue;
            const line = raw.trim();
            if (!line) continue;
            const parts = line.split(',');
            if (parts.length < 3) continue;
            let lng = parseFloat((parts[isHash ? 0 : 1] || '').trim());
            let lat = parseFloat((parts[isHash ? 1 : 2] || '').trim());
            // 初步过滤：数值合法性与正常范围
            if (!isFinite(lng) || !isFinite(lat)) continue;
            if (lng === 0 || lat === 0) continue; // 丢弃0.0异常点
            if (lng < -180 || lng > 180 || lat < -90 || lat > 90) continue; // 超出经纬度范围丢弃

            // 将输入坐标转换为WGS84
            let w;
            if (coordSys === 'wgs84' || coordSys === 'cgcs2000') {
                w = { lng, lat };
            } else if (coordSys === 'gcj02') {
                w = gcj02ToWgs84(lng, lat);
            } else if (coordSys === 'bd09') {
                const g = bd09ToGcj02(lng, lat);
                w = gcj02ToWgs84(g.lng, g.lat);
            } else {
                w = { lng, lat };
            }
            // 转换结果兜底检查
            if (!isFinite(w.lng) || !isFinite(w.lat)) continue;
            if (w.lng < -180 || w.lng > 180 || w.lat < -90 || w.lat > 90) continue;

            // 使用WGS84坐标绘制到地图
            pts.push(new T.LngLat(w.lng, w.lat));
        }
        return pts;
    }

    function drawTrackFromPoints(points){
        // 先移除旧轨迹（不影响轮廓）
        clearTrackOverlays(false);
        const polyline = new T.Polyline(points, {
            color: '#FF3B30',
            weight: 2.5,
            opacity: 0.9
        });
        if (map) {
            map.addOverLay(polyline);
        }
        currentTracks.push(polyline);
    }

    function clearTrackOverlays(resetArray = true){
        try {
            currentTracks.forEach(pl => {
                if (pl && map && map.removeOverLay) {
                    try { map.removeOverLay(pl); } catch (e) { console.warn('移除轨迹失败:', e); }
                }
            });
            if (resetArray) currentTracks = [];
        } catch (e) {
            console.warn('清空轨迹时出错:', e);
        }
    }


    function fitViewportToTrack(points){
        try {
            if (!map || !map.setViewport || !points || !points.length) return;
            map.setViewport(points);
        } catch (e) {
            console.warn('轨迹视图居中失败:', e);
        }
    }

    // ========= 轨迹回放功能 =========
    let playbackState = { points: [], idx: 0, speed: 1, timer: null, running: false, marker: null, line: null, path: [] };

    function bindPlaybackControls(){
        const startBtn = document.getElementById('playbackStartBtn');
        const pauseBtn = document.getElementById('playbackPauseBtn');
        const stopBtn = document.getElementById('playbackStopBtn');
        const speedSel = document.getElementById('playbackSpeedSelect');
        const timeSlider = document.getElementById('playbackTimeSlider');
        const timeCursor = document.getElementById('playbackTimeCursor');
        const ta = document.getElementById('trackTextarea');
        if (!startBtn || !pauseBtn || !stopBtn || !speedSel) return;

        // 初始按钮状态
        updatePlaybackButtonsState('idle');

        startBtn.addEventListener('click', function(){
            try {
                const text = (ta && ta.value || '').trim();
                if (!text) { alert('请粘贴轨迹文本（时间戳,经度,纬度）'); return; }
                const pts = parseTrackTextWithTime(text);
                if (pts.length < 2) { alert('有效轨迹点不足，至少需要两点'); return; }
                startPlayback(pts);
                // 状态在startPlayback中已设置为playing
            } catch (e) {
                alert('开始回放失败：' + (e && e.message ? e.message : e));
                console.error('开始回放异常:', e);
            }
        });

        pauseBtn.addEventListener('click', function(){
            if (!playbackState.running) {
                // 继续
                playbackState.running = true;
                scheduleNext();
                updatePlaybackButtonsState('playing');
            } else {
                // 暂停
                if (playbackState.timer) { clearTimeout(playbackState.timer); playbackState.timer = null; }
                playbackState.running = false;
                updatePlaybackButtonsState('paused');
            }
        });

        stopBtn.addEventListener('click', function(){ 
            stopPlayback(); 
            updatePlaybackButtonsState('idle');
        });

        speedSel.addEventListener('change', function(){
            const v = parseFloat(speedSel.value);
            playbackState.speed = (isFinite(v) && v > 0) ? v : 1;
        });

        if (timeSlider) {
            timeSlider.addEventListener('input', function(){
                const ms = parseInt(timeSlider.value, 10);
                const txt = formatTimeForLabel(ms);
                if (timeCursor) timeCursor.textContent = txt;
            });
            timeSlider.addEventListener('change', function(){
                jumpToSliderTime();
            });
        }
    }

    function parseTrackTextWithTime(text){
        const coordSysEl = document.getElementById('trackCoordSysSelect') || document.getElementById('coordSysSelect');
        const coordSys = (coordSysEl && coordSysEl.value) || 'wgs84';
        const isHash = text.indexOf('#') !== -1;
        const items = isHash ? text.split('#') : text.split(/\r?\n/);
        const out = [];
        for (let i=0;i<items.length;i++){
            const raw = items[i];
            if (!raw) continue;
            const line = raw.trim();
            if (!line) continue;
            const parts = line.split(',');
            if (parts.length < 3) continue;
            const tsRaw = (parts[isHash ? 2 : 0] || '').trim();
            const ts = (tsRaw || '').replace(/\D/g,'');
            let lng = parseFloat((parts[isHash ? 0 : 1] || '').trim());
            let lat = parseFloat((parts[isHash ? 1 : 2] || '').trim());
            if (!isFinite(lng) || !isFinite(lat)) continue;
            if (lng === 0 || lat === 0) continue;
            if (lng < -180 || lng > 180 || lat < -90 || lat > 90) continue;
            const t = parseTimestamp(ts);
            if (!t) continue;
            let w;
            if (coordSys === 'wgs84' || coordSys === 'cgcs2000') {
                w = { lng, lat };
            } else if (coordSys === 'gcj02') {
                w = gcj02ToWgs84(lng, lat);
            } else if (coordSys === 'bd09') {
                const g = bd09ToGcj02(lng, lat);
                w = gcj02ToWgs84(g.lng, g.lat);
            } else { w = { lng, lat }; }
            if (!isFinite(w.lng) || !isFinite(w.lat)) continue;
            if (w.lng < -180 || w.lng > 180 || w.lat < -90 || w.lat > 90) continue;
            out.push({ ll: new T.LngLat(w.lng, w.lat), time: t, ts });
        }
        out.sort((a,b)=>a.time - b.time);
        return out;
    }

    function parseTimestamp(ts){
        const tstr = (ts || '').replace(/\D/g,'');
        const m = tstr && tstr.match(/^\d{14}$/);
        if (!m) return null;
        const y = parseInt(tstr.slice(0,4),10);
        const M = parseInt(tstr.slice(4,6),10) - 1;
        const d = parseInt(tstr.slice(6,8),10);
        const h = parseInt(tstr.slice(8,10),10);
        const m2 = parseInt(tstr.slice(10,12),10);
        const s = parseInt(tstr.slice(12,14),10);
        const dt = new Date(y,M,d,h,m2,s);
        return isNaN(dt.getTime()) ? null : dt;
    }

    function startPlayback(points){
        console.log('[Playback] startPlayback: 点数=', points && points.length);
        stopPlayback();
        playbackState.points = points;
        playbackState.idx = 0;
        playbackState.speed = playbackState.speed || 1;
        playbackState.running = true;
        // 配置时间滑动条，并尊重现有滑块位置作为起始
        configureTimeSlider(points);
        // 启用滑块
        const slider = document.getElementById('playbackTimeSlider');
        if (slider) slider.disabled = false;
        let initIdx = 0;
        if (slider && slider.min && slider.max) {
            const ms = parseInt(slider.value, 10);
            if (isFinite(ms)) initIdx = findIndexByTime(points, ms);
        }
        playbackState.idx = initIdx;
        const first = points[initIdx];
        console.log('[Playback] 首点:', first && first.ts, first && first.ll, 'initIdx=', initIdx);
        playbackState.path = points.slice(0, initIdx+1).map(p=>p.ll);
        playbackState.line = new T.Polyline(playbackState.path, { color: '#00FFFF', weight: 3, opacity: 0.9 });
        if (map) {
            map.addOverLay(playbackState.line);
        }
        currentTracks.push(playbackState.line);
        // 创建并定位DOM标记以保证可见移动
        ensurePlaybackDom(first.ll);
        updatePlaybackDom(first.ll);
        updatePlaybackTimeLabel(first.ts);
        try { fitViewportToTrack(points.map(p=>p.ll)); } catch(e){}
        // 更新按钮状态
        updatePlaybackButtonsState('playing');
        scheduleNext();
    }

    function scheduleNext(){
        if (!playbackState.running) return;
        if (!playbackState.points || playbackState.idx >= playbackState.points.length - 1) {
            playbackState.running = false;
            console.log('[Playback] 回放结束：idx=', playbackState.idx, '点数=', playbackState.points ? playbackState.points.length : 0);
            updatePlaybackButtonsState('idle'); // 播放结束后按钮回到初始状态：开始可点，继续/结束灰化
            return;
        }
        const next = playbackState.points[playbackState.idx+1];
        const speed = playbackState.speed || 1;
        const delay = Math.max(4, Math.round(1000 / speed)); // 1x=1000ms/点，2x=500ms/点...
        console.log('[Playback] scheduleNext: idx=', playbackState.idx, '->', playbackState.idx+1, 'delay=', delay, 'speed=', speed);
        playbackState.timer = setTimeout(()=>{
            playbackState.idx++;
            const nextLL = next.ll;
            console.log('[Playback] 下一点:', next && next.ts, nextLL);
            try {
                // 维护路径数组
                playbackState.path = playbackState.path || [];
                playbackState.path.push(nextLL);
                console.log('[Playback] 路径长度=', playbackState.path.length);
                // 使用DOM标记进行移动（容器/图层坐标）
                if (!playbackDom.el) console.log('[Playback] DOM标记不存在，将尝试创建');
                updatePlaybackDom(nextLL);
                // 折线更新：优先setLngLats，兜底重建
                if (playbackState.line && typeof playbackState.line.setLngLats === 'function') {
                    try { playbackState.line.setLngLats(playbackState.path); }
                    catch(e){
                        console.warn('[Playback] setLngLats失败，重建折线', e);
                        if (map) { try { map.removeOverLay(playbackState.line); } catch(e){} }
                        playbackState.line = new T.Polyline(playbackState.path, { color: '#00FFFF', weight: 3, opacity: 0.9 });
                        if (map) map.addOverLay(playbackState.line);
                    }
                } else {
                    console.log('[Playback] 折线不支持setLngLats，重建');
                    if (playbackState.line && map) { try { map.removeOverLay(playbackState.line); } catch(e){} }
                    playbackState.line = new T.Polyline(playbackState.path, { color: '#00FFFF', weight: 3, opacity: 0.9 });
                    if (map) map.addOverLay(playbackState.line);
                }
            } catch(e) { console.warn('更新回放覆盖物失败:', e); }
            updatePlaybackTimeLabel(next.ts);
            scheduleNext();
        }, delay);
    }

    function stopPlayback(){
        if (playbackState.timer) { clearTimeout(playbackState.timer); playbackState.timer = null; }
        playbackState.running = false;
        playbackState.idx = 0;
        try {
            // 移除DOM标记
            removePlaybackDom();
            if (playbackState.marker && map) map.removeOverLay(playbackState.marker);
            if (playbackState.line && map) map.removeOverLay(playbackState.line);
        } catch(e){}
        playbackState.marker = null;
        playbackState.line = null;
        updatePlaybackTimeLabel('—');
        // 按钮回到初始状态
        updatePlaybackButtonsState('idle');
    }

    function updatePlaybackTimeLabel(text){
        const el = document.getElementById('playbackTimeLabel');
        if (el) el.textContent = '时间：' + (text || '—');
    }

    // 时间滑动条：配置与跳转
    function configureTimeSlider(points){
        try {
            const slider = document.getElementById('playbackTimeSlider');
            const cursor = document.getElementById('playbackTimeCursor');
            if (!slider || !points || !points.length) return;
            const minMs = points[0].time.getTime();
            const maxMs = points[points.length - 1].time.getTime();
            const prev = parseInt(slider.value, 10);
            slider.min = String(minMs);
            slider.max = String(maxMs);
            slider.step = '1000'; // 以秒为步进
            let val = (isFinite(prev) && prev >= minMs && prev <= maxMs) ? prev : minMs;
            slider.value = String(val);
            if (cursor) cursor.textContent = formatTimeForLabel(val);
        } catch(e) { console.warn('配置时间滑动条失败:', e); }
    }
    function formatTimeForLabel(ms){
        if (!isFinite(ms)) return '—';
        const d = new Date(ms);
        const pad = n => String(n).padStart(2,'0');
        const y = d.getFullYear();
        const M = pad(d.getMonth()+1);
        const da = pad(d.getDate());
        const h = pad(d.getHours());
        const m = pad(d.getMinutes());
        const s = pad(d.getSeconds());
        return `${y}-${M}-${da} ${h}:${m}:${s}`;
    }
    function findIndexByTime(points, ms){
        try {
            if (!points || !points.length) return 0;
            const n = points.length;
            const minMs = points[0].time.getTime();
            const maxMs = points[n-1].time.getTime();
            if (!isFinite(ms)) return 0;
            if (ms <= minMs) return 0;
            if (ms >= maxMs) return n-1;
            let lo = 0, hi = n - 1, ans = 0;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const t = points[mid].time.getTime();
                if (t < ms) { lo = mid + 1; ans = lo; }
                else { hi = mid - 1; ans = mid; }
            }
            return Math.max(0, Math.min(n-1, ans));
        } catch(e){ console.warn('findIndexByTime失败:', e); return 0; }
    }
    function jumpToSliderTime(){
        try {
            const slider = document.getElementById('playbackTimeSlider');
            if (!slider || !playbackState.points || !playbackState.points.length) return;
            const ms = parseInt(slider.value, 10);
            if (!isFinite(ms)) return;
            const idx = findIndexByTime(playbackState.points, ms);
            playbackState.idx = idx;
            const pts = playbackState.points;
            const ll = pts[idx].ll;
            playbackState.path = pts.slice(0, idx+1).map(p=>p.ll);
            // 更新折线
            try {
                if (playbackState.line && typeof playbackState.line.setLngLats === 'function') {
                    playbackState.line.setLngLats(playbackState.path);
                } else {
                    if (playbackState.line && map) { try { map.removeOverLay(playbackState.line); } catch(e){} }
                    playbackState.line = new T.Polyline(playbackState.path, { color: '#00FFFF', weight: 3, opacity: 0.9 });
                    if (map) map.addOverLay(playbackState.line);
                }
            } catch(e){ console.warn('滑块更新折线失败:', e); }
            // 更新标记与时间
            ensurePlaybackDom(ll);
            updatePlaybackDom(ll);
            updatePlaybackTimeLabel(pts[idx].ts);
            // 若正在播放，立即按新位置继续
            if (playbackState.running) {
                if (playbackState.timer) { clearTimeout(playbackState.timer); playbackState.timer = null; }
                scheduleNext();
            }
        } catch(e) { console.warn('滑块跳转失败:', e); }
    }

    // DOM标记：使用容器坐标实现可见移动
    let playbackDom = { el: null, lastLL: null, bound: false };

    function ensurePlaybackDom(ll){
        try {
            playbackDom.lastLL = ll;
            const pane = (map && map.getPanes && map.getPanes().overlayPane) || document.getElementById('mapContainer');
            if (!pane) { console.warn('未找到overlayPane或mapContainer'); return; }
            if (!playbackDom.el) {
                const el = document.createElement('div');
                el.id = 'playbackDomMarker';
                el.style.position = 'absolute';
                el.style.width = '16px';
                el.style.height = '16px';
                el.style.borderRadius = '50%';
                el.style.background = '#2C64A7';
                el.style.border = '2px solid #fff';
                el.style.boxShadow = '0 0 0 1px rgba(0,0,0,.25)';
                el.style.zIndex = '9999';
                pane.appendChild(el);
                playbackDom.el = el;
                console.log('[Playback] 创建DOM标记，父节点=', pane === document.getElementById('mapContainer') ? '#mapContainer' : 'overlayPane');
                bindPlaybackDomEvents();
            }
            updatePlaybackDom(ll);
        } catch(e) { console.warn('创建DOM标记失败:', e); }
    }

    function updatePlaybackDom(ll){
        try {
            playbackDom.lastLL = ll;
            if (!map || !playbackDom.el || !ll) { console.log('[Playback] update取消：map/el/ll缺失'); return; }
            let p;
            if (typeof map.lngLatToLayerPoint === 'function') {
                p = map.lngLatToLayerPoint(ll);
                console.log('[Playback] 使用layerPoint定位:', ll && ll.lng, ll && ll.lat, '=>', p && p.x, p && p.y);
            } else if (typeof map.lngLatToContainerPoint === 'function') {
                p = map.lngLatToContainerPoint(ll);
                console.log('[Playback] 使用containerPoint定位:', ll && ll.lng, ll && ll.lat, '=>', p && p.x, p && p.y);
            } else {
                console.warn('地图对象不支持lngLat到像素坐标转换');
                return;
            }
            playbackDom.el.style.left = p.x + 'px';
            playbackDom.el.style.top = p.y + 'px';
        } catch(e) { console.warn('更新DOM标记位置失败:', e); }
    }

    function bindPlaybackDomEvents(){
        if (playbackDom.bound) return;
        const updater = function(){
            try {
                if (!map || !playbackDom.el || !playbackDom.lastLL) return;
                let p;
                if (typeof map.lngLatToLayerPoint === 'function') {
                    p = map.lngLatToLayerPoint(playbackDom.lastLL);
                } else if (typeof map.lngLatToContainerPoint === 'function') {
                    p = map.lngLatToContainerPoint(playbackDom.lastLL);
                }
                if (!p) return;
                playbackDom.el.style.left = p.x + 'px';
                playbackDom.el.style.top = p.y + 'px';
            } catch(e){}
        };
        try {
            map.addEventListener('move', updater);
            map.addEventListener('zoom', updater);
            playbackDom.bound = true;
        } catch(e){}
    }

    function removePlaybackDom(){
        try {
            const el = playbackDom.el;
            playbackDom.lastLL = null;
            if (el && el.parentNode) el.parentNode.removeChild(el);
        } catch(e){}
        playbackDom.el = null;
        playbackDom.bound = false;
    }

</script>
</body>

</html>
